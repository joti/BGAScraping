# BGA_Scraping.py
# Python program to get data from BGA

import time
import sys
import yaml
import re
import os.path
import sqlite3
import gspread
import sheet_utils

from pathlib import Path
from config import PATHS, BGA_LOGIN, BGA_DATA, create_driver
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum
from typing import Optional
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import ElementClickInterceptedException
from selenium.common.exceptions import TimeoutException
from selenium.common.exceptions import WebDriverException
from urllib3.exceptions import ReadTimeoutError
from google.oauth2.service_account import Credentials
from models import PlayerELO

# terminology:
# game = the type of board game
# table = one particular match of a given game
class tableClass :
    def __init__(self,seq,tableId,endDate,endTst,newELO,unranked,newRecord,newRecByDay,fake):
        self.seq = seq
        self.tableId = tableId
        self.endDate = endDate
        self.endTst = endTst
        self.newELO = newELO
        self.unranked = unranked
        self.newRecord = newRecord
        self.newRecByDay = newRecByDay
        self.fake = fake

class CarcEvent(str, Enum):
    START= "S"
    TILE = "T"
    MEEPLE = "M"
    COMPLETE = "C"
    FINAL = "F"
    POINTS = "P"
    DISCARD = "D"
    CONCEDE = "X"
    ABANDON = "A"
    TIMEOVER = "O"

class CarcFeature(str, Enum):
    ROAD = "R"
    CITY = "C"
    MONASTERY = "M"
    FIELD = "F"
    VOID = ""

class CarcTile(str, Enum):
    FFFF  = "FFFF"
    RFFF  = "RFFF"
    RFRF  = "RFRF"
    RRFF  = "RRFF"
    RRRF  = "RRRF"
    RRRR  = "RRRR"
    CFFF  = "CFFF"
    CRFR  = "CRFR"
    CFRR  = "CFRR"
    CRRF  = "CRRF"
    CRRR  = "CRRR"
    CFCF  = "CFCF"
    CFCFP = "CFCFp"
    CFCFS = "CFCFs"
    CCFF  = "CCFF"
    CCFFP = "CCFFp"
    CCFFS = "CCFFs"
    CCRR  = "CCRR"
    CCRRP = "CCRRp"
    CCCF  = "CCCF"
    CCCFP = "CCCFp"
    CCCR  = "CCCR"
    CCCRP = "CCCRp"
    CCCCP = "CCCCp"
    VOID  = ""

CARC_TILES_ROW1 = ["CCCR", "CCCRp","CCCRp","CCFF", "CCFF", "CCFF", "CCFFp","CCFFp","CCRR", "CCRR", "CCRR", "CCRRp","CCRRp","CFCF", "CFCFp","CFCFp"]
CARC_TILES_ROW2 = ["CCFFs","CCFFs","CFCFs","CFCFs","CFCFs","CFFF", "CFFF", "CFFF", "CFFF", "CFFF", "CFRR", "CFRR", "CFRR", "CRRF", "CRRF", "CRRF" ]
CARC_TILES_ROW3 = ["CRRR", "CRRR", "CRRR", "CRFR", "CRFR", "CRFR", "CRFR", "RFRF", "RFRF", "RFRF", "RFRF", "RFRF", "RFRF", "RFRF", "RFRF", "RRFF" ]
CARC_TILES_ROW4 = ["RRFF", "RRFF", "RRFF", "RRFF", "RRFF", "RRFF", "RRFF", "RRFF", "RRRF", "RRRF", "RRRF", "RRRF", "RRRR", "FFFF", "FFFF", "FFFF" ]
CARC_TILES_ROW5 = ["FFFF", "RFFF", "RFFF", "CCCCp","CCCF", "CCCF", "CCCF", "CCCFp","FFFF", "FFFF", "FFFF", "FFFF", "FFFF", "FFFF", "FFFF", "FFFF" ]


# dataclasses for saving data to DB
@dataclass
class Tournament:
    code: str
    name: str
    inbga: bool
    origname: str
    id: Optional[int] = None # auto-generated by DBMS

@dataclass
class Table:
    tournament_code: str # NONPERSISTENT
    code: str
    game_code: int
    width: int
    height: int
    duration: str
    ccities: int
    id: Optional[int] = None # auto-generated by DBMS
    tournament_id: int = 0 # link to a tournament
    
@dataclass
class Player:
    code: str
    name: str
    team: str = ""
    id: Optional[int] = None # auto-generated by DBMS

@dataclass
class TablePlayer:
    seq: int # unique within a table
    table_code: str # NONPERSISTENT
    player_code: str # NONPERSISTENT
    score: int # official final score (e.g. when the player runs out of time)
    bgascore: int # original final score on BGA
    newrank: int
    rankchg: int
    winner: bool
    outoftime: bool
    time: str = ""
    roadpt: int = 0
    citypt: int = 0
    monasterypt: int = 0
    fieldpt: int = 0
    meeples: int = 0
    id: Optional[int] = None # auto-generated by DBMS
    table_id: int = 0 # link to a table
    player_id: int = 0 # link to a player

@dataclass
class CarcStep:
    table_code: str # NONPERSISTENT
    seq: int
    turn: int
    bgamove: int # move number according to BGA
    turnplayer: int # which player's turn; refers to TablePlayer.seq
    stepplayer: int # which player's step (e.g. who's getting points); refers to TablePlayer.seq; 0 = final scoring
    event: CarcEvent
    feature: CarcFeature # in case of MEEPLE, COMPLETE or POINTS event
    tile: CarcTile # in case of TILE or DISCARD event
    score: int
    desc: str
    time: str # 2025. 03. 03. 1:07:06 -> 2025.03.03. 01:07:06
    clock1: str
    clock2: str
    id: Optional[int] = None # auto-generated by DBMS
    table_id: int = 0 # link to a table
    
# globális Selenium objektumok
DRIVER = None
WAIT = None

def exit_program():
    print("Exiting...")
    sys.exit(0)

def restart_driver():
    global DRIVER, WAIT
    try:
        DRIVER.quit()
    except Exception:
        pass
    time.sleep(2)
    DRIVER, WAIT = create_driver(headless=headless, no_sandbox=no_sandbox)

def close_popup( max_attempts = 3 ): 
    global popupClosed 
    if popupClosed: 
        return 
        
    # We open the main page just to dismiss popups if there's any
    mainpage_link = BGA_DATA['urls']['main'] 
    last_exc = None 
    
    for attempt in range(1, max_attempts + 1): 
        try: 
            DRIVER.get(mainpage_link) 
            popup = WAIT.until(EC.element_to_be_clickable((By.ID, "didomi-notice-agree-button"))) 
            popup.click() 
            print("Popup closed") 
            popupClosed = True 
            return 
        except TimeoutException: 
            print("No clickable popup found") 
            popupClosed = True 
            return 
        except Exception as e: 
            last_exc = e 
            print(f"Popup closing FAILED: {repr(e)}") 
            restart_driver() 
            time.sleep(5) 
            
    raise last_exc

def login24():
    # Deprecated login method
    login_link = BGA_DATA['urls']['login']
    print(login_link);
    DRIVER.get(login_link)

    username = BGA_LOGIN['user']
    pw = BGA_LOGIN['password']

    WAIT.until(EC.visibility_of_element_located((By.ID, "username_input")))
    it_username = DRIVER.find_element(By.ID, "username_input")
    it_username.send_keys(username)

    WAIT.until(EC.visibility_of_element_located((By.ID, "password_input")))
    password = DRIVER.find_element(By.ID, "password_input")
    password.send_keys(pw)

    WAIT.until(EC.visibility_of_element_located((By.ID, "submit_login_button")))
    DRIVER.find_element(By.ID, "submit_login_button").click()

def login():
    global loggedIn
    global lang
    global othlang
    
    if loggedIn :
        return        

    login_link = BGA_DATA['urls']['login']
    print(login_link);
    DRIVER.get(login_link)

    username = BGA_LOGIN['user']
    pw = BGA_LOGIN['password']

    WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[1]/div/div[2]/form/div[2]/div/div/input')))
    it_username = DRIVER.find_element(By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[1]/div/div[2]/form/div[2]/div/div/input')

    it_username.send_keys(username)
    time.sleep(2)

    btn = None
    for element in DRIVER.find_elements(By.XPATH, '//*[@id="account-module"]//form//a'):
        if element.is_displayed():
            btn = element
            break
    if btn:
        btn.click()
    else:
        raise NoSuchElementException("No visible button found to submit username")
    time.sleep(1)

    WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[2]/div/form/div[1]/div[2]/div/input')))
    it_password = DRIVER.find_element(By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[2]/div/form/div[1]/div[2]/div/input')
    it_password.send_keys(pw)
    time.sleep(2)

    btn = None
    for element in DRIVER.find_elements(By.XPATH, '//*[@id="account-module"]//form//a'):
        if element.is_displayed():
            btn = element
            break
    if btn:
        btn.click()
    else:
        raise NoSuchElementException("No visible button found to submit password")
    time.sleep(2)

    # "Let's play" button
    try:
        btn = WAIT.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "#account-module .bga-registration-form__letsplay_button a")))
        btn.click()
    except Exception:
        print("CSS_SELECTOR NOK")
        btn = WAIT.until(EC.element_to_be_clickable((By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[3]/div[2]/div[3]/div[3]/div/div/a')))
        btn.click()
        print("XPATH OK")
    
    time.sleep(1)
    loggedIn = True
    print("login successful")

    forumlink = DRIVER.find_element(By.XPATH, "//a[contains(@href, 'forum')]")
    if forumlink.text.upper() == 'FORUMS' :
        lang = "en"
        othlang = "hu"
    print("Language: " + lang)
    print(" ")

def login_with_retry( max_attempts = 3 ):
    global DRIVER, WAIT, loggedIn

    last_exc = None
    for attempt in range(1, max_attempts + 1):
        try:
            print(f"Login attempt {attempt}/{max_attempts}")
            loggedIn = False
            login()
            return
        except Exception as e:
            last_exc = e
            print(f"Login FAILED: {repr(e)}")
            restart_driver()
            time.sleep(5)

    raise last_exc

def init_db():

    db_path = PATHS['db_path']

    if os.path.isdir(db_path):
        print(f"Database file name missing: {db_path}")
        return

    if os.path.exists(db_path) and not "reset" in subfunc_set :
        print(f"Database file already exists: {db_path}")
        return

    db_dir = os.path.dirname(db_path)
    if not os.path.exists(db_dir):
        print(f"Directory does not exist: {db_dir}")
        return

    try:

        connection = sqlite3.connect(db_path)
        cursor = connection.cursor()

        if "reset" in subfunc_set :
            cursor.execute("""
            DROP TABLE IF EXISTS tournament
            """)
            print("Table 'tournament' dropped")
            cursor.execute("""
            DROP TABLE IF EXISTS table_
            """)
            print("Table 'table_' dropped")
            cursor.execute("""
            DROP TABLE IF EXISTS player
            """)
            print("Table 'player' dropped")
            cursor.execute("""
            DROP TABLE IF EXISTS tableplayer
            """)
            print("Table 'tableplayer' dropped")
            cursor.execute("""
            DROP TABLE IF EXISTS carcstep
            """)
            print("Table 'carcstep' dropped")

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS tournament (
            tournament_id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            name TEXT NOT NULL,           -- WTCOC25 - Group 1 - FIN-HUN / TCF - FIN-HUN 2025-03-09
            origname TEXT DEFAULT '',     -- Tournament's original name in BGA
            inbga BOOLEAN NOT NULL CHECK (inbga IN (0, 1))
        )
        """)
        print("Table 'tournament' created")

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS table_ (
            table_id INTEGER PRIMARY KEY AUTOINCREMENT,
            tournament_id INTEGER NOT NULL,
            code TEXT UNIQUE NOT NULL,
            game_code TEXT NOT NULL,
            width INTEGER,
            height INTEGER,
            duration TEXT,
            ccities INTEGER,
            FOREIGN KEY (tournament_id) REFERENCES tournament(tournament_id)
        )
        """)
        print("Table 'table_' created")

        cursor.execute("""
        CREATE INDEX idx_table_trn_id ON table_(tournament_id)
        """)
        print("Index 'idx_table_trn_id' created")
    
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS player (
            player_id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            name TEXT UNIQUE NOT NULL
        )
        """)
        print("Table 'player' created")

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS tableplayer (
            tableplayer_id INTEGER PRIMARY KEY AUTOINCREMENT,
            table_id INTEGER NOT NULL,
            player_id INTEGER NOT NULL,
            seq INTEGER NOT NULL,
            score INTEGER NOT NULL,
            bgascore INTEGER NOT NULL,
            newrank INTEGER NOT NULL,
            rankchg INTEGER NOT NULL,
            roadpt INTEGER NOT NULL,
            citypt INTEGER NOT NULL,
            monasterypt INTEGER NOT NULL,
            fieldpt INTEGER NOT NULL,
            meeples INTEGER NOT NULL,
            time TEXT NOT NULL,
            winner BOOLEAN NOT NULL CHECK (winner IN (0, 1)),
            outoftime BOOLEAN NOT NULL CHECK (outoftime IN (0, 1)),
            FOREIGN KEY (table_id) REFERENCES table_(table_id),
            FOREIGN KEY (player_id) REFERENCES player(player_id)
        )
        """)
        print("Table 'tableplayer' created")

        cursor.execute("""
        CREATE UNIQUE INDEX idx_tableplayer_tbl_id ON tableplayer(table_id, player_id)
        """)
        print("Index 'idx_tableplayer_tbl_id' created")
        cursor.execute("""
        CREATE INDEX idx_tableplayer_pyr_id ON tableplayer(player_id)
        """)
        print("Index 'idx_tableplayer_pyr_id' created")

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS carcstep (
            carcstep_id INTEGER PRIMARY KEY AUTOINCREMENT,
            table_id INTEGER NOT NULL,
            seq INTEGER NOT NULL,
            turn INTEGER NOT NULL,
            bgamove INTEGER NOT NULL,
            turnplayer INTEGER NOT NULL,
            stepplayer INTEGER NOT NULL,
            event TEXT NOT NULL,
            feature TEXT,
            tile TEXT,
            score INTEGER,
            desc TEXT,
            time TEXT,
            clock1 TEXT,
            clock2 TEXT,
            FOREIGN KEY (table_id) REFERENCES table_(table_id)
        )
        """)
        print("Table 'carcstep' created")

        cursor.execute("""
        CREATE UNIQUE INDEX idx_carcstep_tbl_id ON carcstep(table_id, seq)
        """)
        print("Index 'idx_carcstep_tbl_id' created")

        connection.commit()

    except Exception as e:
        print(f"Error: {e}")
        if connection:
            connection.rollback()
    finally:
        if connection :
            print("Closing database connection...")
            connection.close()

def get_carctile_by_bgpos(bg_position):

    carctile: CarcTile = CarcTile.VOID
    match = re.search(r'\s*(\d+)(?:\.\d+)?%\s+(\d+)(?:\.\d+)?%', bg_position)
    if match:
        x_pos = int(match.group(1))
        y_pos = int(match.group(2))

        #X values: 0, 6, 13, 20, 26, 33, 40, 46, 53, 60, 66, 73, 80, 86, 93, 100
        #Y values: 0, 11, 22, 33, 44

        col = 0
        tilestr = ""
        match x_pos :
            case  0 : col = 1
            case  6 : col = 2   
            case 13 : col = 3   
            case 20 : col = 4   
            case 26 : col = 5   
            case 33 : col = 6   
            case 40 : col = 7   
            case 46 : col = 8   
            case 53 : col = 9   
            case 60 : col = 10   
            case 66 : col = 11   
            case 73 : col = 12   
            case 80 : col = 13   
            case 86 : col = 14   
            case 93 : col = 15   
            case 100 : col = 16   
        match y_pos :
            case 0 : tilestr = CARC_TILES_ROW1[col - 1]
            case 11 : tilestr = CARC_TILES_ROW2[col - 1]
            case 22 : tilestr = CARC_TILES_ROW3[col - 1]
            case 33 : tilestr = CARC_TILES_ROW4[col - 1]
            case 44 : tilestr = CARC_TILES_ROW5[col - 1]

        if tilestr != "" :
            carctile = CarcTile(tilestr)
        else :
            print(f"x: {x_pos}, y: {y_pos}")

    if carctile == CarcTile.VOID :
        print("Tile cannot be identified.")

    return carctile   
        
    
def get_connection():

    db_path = PATHS['db_path']
    if not os.path.exists(db_path):
        print(f"Database file does not exists: {db_path}")
        return None

    print("Database file: " + db_path)
    return sqlite3.connect(db_path)
    

def get_profilepic( player : PlayerELO ):

    profile_url = (BGA_DATA['urls']['profile'].
                     replace('{p1}', player.bga_id))
    print(f"Avatar from {profile_url}:")

    DRIVER.get(profile_url)

    try:
        WAIT.until(EC.presence_of_element_located((By.CSS_SELECTOR, "#player_avatar img")))
        img = DRIVER.find_element(By.CSS_SELECTOR, "#player_avatar img")
        avatar_url = img.get_attribute("src")
    except NoSuchElementException:
        avatar_url = None
        print("NoSuchElementException")

    if avatar_url:
        player.profilepic = avatar_url
        print(player.profilepic)
        

def elo_hist( game_def,     # id or name of the game,
              players : list[PlayerELO], # data of players
              min_date,     # start of the period to check (no limit if empty)
              max_date,     # end of the period to check (no limit if empty)
              file_name,    # name of file to export data
              update_profilepic # profile picture update
            ):

    global lang
    global othlang

    INACTIVITY_DAYS = 92

    maxDateStr = ""
    minDateStr = ""
    maxDateDT = datetime.max
    minDateDT = datetime.min
    minDateDTDef = datetime.min
    filter_mindate = datetime.min
    current_date = datetime.max
    
    maxTst = None
    minTst = None

    errorStr = ""

    if max_date != "":
        maxDateStr = max_date.replace("-", ".")
        print("Max date: " + maxDateStr)        
        try:
            maxDateDT = datetime.strptime(maxDateStr, '%Y.%m.%d')
        except ValueError as e:
            print("End of period is not a proper date value (YYYY-MM-DD)")
            exit_program()
        #time.mktime(maxDateTime.timetuple())
    else :
        if "avg" in subfunc_set :
            maxDateStr = datetime.today().strftime('%Y.%m.%d')
    if maxDateStr != "" :
        maxTstDT = datetime(int(maxDateStr[0:4]), int(maxDateStr[5:7]), int(maxDateStr[8:10]), 12, 0)
        maxTst = datetime.timestamp(maxTstDT)

    if min_date != "":
        minDateStr = min_date.replace("-", ".").rstrip(".")
        print("Min date: " + minDateStr)        
        try:
            minDateDTDef = datetime.strptime(minDateStr, '%Y.%m.%d')
        except ValueError as e:
            print("Start of period is not a proper date value (YYYY-MM-DD)")
            exit_program()
            
        minTstDT = datetime(int(minDateStr[0:4]), int(minDateStr[5:7]), int(minDateStr[8:10]), 0, 0)
        minTst = datetime.timestamp(minTstDT)

    game_name = 'unknown'
    game_id = '0'
    if game_def != "" :
        for k, v in BGA_DATA['gameids'].items():
            if game_def.upper().replace(" ", "").replace("_", "") == k.upper().replace(" ", "").replace("_", "") or game_def == str(v) :
                game_id = str(v)
                game_name = k
    else :
        game_id = '1'
        game_name = 'Carcassonne'

    if game_id == '0' :
        print("Unknown game")
        exit_program()
        
    print("Game: " + game_name)
        
    if len(players) == 0:
        player_name = BGA_LOGIN['user']
        players.append(PlayerELO(
            bga_name = player_name
        ))
    

    close_popup()

    # we need the player's id in BGA
    # to get the community page we need to log in
    login_with_retry()
    time.sleep(1)

    gameStatsLoadTotalTime = 0
    gameStatsProcTotalTime = 0
    tableSeq = 0

    start_millisec = int(time.time() * 1000)

    for player in players:
        if player.skip:
            continue

        player_name = player.bga_name
        player.status = 2
        print(f"Player: {player_name} - {datetime.now().isoformat(sep=' ', timespec='milliseconds')}")

        if update_profilepic:
            get_profilepic(player)
        
        playerRowLimit = 200

        if file_name == ".":
            player_file = (player_name + "__" + game_name).lower().replace(" ", "_") + ".elo"
        elif file_name != "":
            player_file = file_name
        else :
            player_file = ""
            
        output_dir = PATHS['output_dir']
        if player_file != "" and output_dir != "" :
            if os.path.isdir(output_dir):
                player_file = output_dir + player_file
            else :
                print(output_dir + " does not exist")
        if player_file != "" :
            print("Output file: " + player_file)

        if not player.last_table_date:
            minDateDT = minDateDTDef
        else:
            minDateStr = player.last_table_date.replace("-", ".").rstrip(".")
            try:
                minDateDT = datetime.strptime(minDateStr, '%Y.%m.%d')
            except ValueError as e:
                print("Last table date is not a proper date value (YYYY-MM-DD)")
                exit_program()
            
            minTstDT = datetime(int(minDateStr[0:4]), int(minDateStr[5:7]), int(minDateStr[8:10]), 0, 0)
            minTst = datetime.timestamp(minTstDT)
            playerRowLimit = 30

        if minDateDT != datetime.min :
            print('Start date: %s' % (minDateStr))
        if maxDateDT != datetime.max :
            print('End date: %s' % (maxDateStr))


        if not player.bga_id:
            community_link = BGA_DATA['urls']['community']
            DRIVER.get(community_link)
            time.sleep(1)

            WAIT.until(EC.visibility_of_element_located((By.ID, "findplayer")))
            it_findplayer = DRIVER.find_element(By.ID, "findplayer")
            it_findplayer.send_keys(player_name)
            it_findplayer.send_keys(Keys.ENTER)

            try:
                WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="elo_game_' + game_id + '"]')))
            except TimeoutException:
                print("Player %s has not played the game %s yet." % (player_name, game_name))
                continue

            player_url = DRIVER.current_url
            print("The current url is: " + str(player_url))

            player.bga_id = player_url[(player_url.find('='))+1:]

        startDT = datetime.now()
        print("Gamestats start: " + startDT.isoformat(sep=' ', timespec='milliseconds'))    

        if maxDateDT != datetime.max :
            current_date = maxDateDT + timedelta(days=1)
        else :   
            current_date = startDT + timedelta(days=1)

        if minDateDT != datetime.min :
            filter_mindate = minDateDT + timedelta(days=-1)
        else :
            filter_mindate = datetime.min

        needSearch = True
        tableSeq = 0
        tableNum = 0
        tableIdSet = {}
        tableList = []
        endTst = None
        lastELO = 0
        lastTable = ""
        lastDate = ""
        dateFormat = "%Y.%m.%d"
        
        while needSearch :
            # convert date to lixux timestamp
            unix_timestamp = datetime.timestamp(current_date)
            end_timestamp = str(int(unix_timestamp))

            if filter_mindate == datetime.min :
                gamestats_url = (BGA_DATA['urls']['gamestatsfull'].
                                 replace('{p1}', player.bga_id).
                                 replace('{p2}', game_id).
                                 replace('{p3}', '0').
                                 replace('{p4}', end_timestamp))
            else :
                unix_timestamp = datetime.timestamp(filter_mindate)
                start_timestamp = str(int(unix_timestamp))
                gamestats_url = (BGA_DATA['urls']['gamestatsfull2'].
                                 replace('{p1}', player.bga_id).
                                 replace('{p2}', game_id).
                                 replace('{p3}', '0').
                                 replace('{p4}', start_timestamp).
                                 replace('{p5}', end_timestamp))
            print(gamestats_url)

            millisec1 = int(time.time() * 1000)
            
            trycount = 0
            needSearch = False
            success = False
            while not success:
                try:
                    DRIVER.get(gamestats_url)
                    WAIT.until(EC.visibility_of_element_located((By.XPATH, "//table[@id='gamelist_inner']")))
                    success = True
                except TimeoutException:
                    time.sleep(1)
                    trycount += 1
                except (WebDriverException, ReadTimeoutError) as e:
                    print(f"WebDriverException during gamestats load: {repr(e)}")
                    trycount += 1
                    restart_driver()
                    time.sleep(3)
        
                if trycount == 5:
                    errorStr = "Cannot load gamestat page for " + player_name
                    print(errorStr)
                    if "sheetproc" in subfunc_set:
                        sheet_utils.write_meta_last_run(False, errorStr) 
                    exit_program()            

            #print("Gamestats page loaded.")

            rownum = len(DRIVER.find_elements(by=By.XPATH, value="//table[@id='gamelist_inner']/tr"))

            trycount = 0
            trycause = ""

            if rownum < 10 :
                needSearch = False
            else :    
                time.sleep(0.5)

                # pressing "more tables" until the number of games doesn't increase any more or the number of rows reaches 100
                while trycount < 4:
                    prev_rownum = rownum

                    footer = DRIVER.find_element(By.ID, "overall-footer")
                    location = footer.location_once_scrolled_into_view
                    ##footer.sendKeys(Keys.END);

                    WAIT.until(EC.visibility_of_element_located((By.XPATH, '//a[@class="bga-link"][@id="see_more_tables"]')))
                    WAIT.until(EC.element_to_be_clickable((By.XPATH, '//a[@class="bga-link"][@id="see_more_tables"]')))
                    
                    link = DRIVER.find_element(By.XPATH, '//a[@class="bga-link"][@id="see_more_tables"]')

                    #success = False
                    #while not success:
                    try:
                        link.click()
                        #success = True
                        if trycount > 0 and trycause == "Click":
                            trycount = 0
                    except ElementClickInterceptedException:
                        print("ElementClickInterceptedException. Trycount=" + str(trycount))
                        trycount += 1
                        if trycount == 4 and trycause == "Click":
                            errorStr = "Cannot click 'More tables' button for " + player_name
                            print(errorStr)
                            if "sheetproc" in subfunc_set:
                                sheet_utils.write_meta_last_run(False, errorStr) 
                            exit_program()            

                        trycause = "Click"
                        time.sleep(trycount * 0.2)
                        continue

                    time.sleep(0.05)

                    WAIT.until(EC.visibility_of_element_located((By.XPATH, "//table[@id='gamelist_inner']")))
                    rownum=len(DRIVER.find_elements(by=By.XPATH, value="//table[@id='gamelist_inner']/tr"))

                    if prev_rownum == rownum:
                        trycount += 1
                        trycause = "EqRow"
                        time.sleep(trycount * 0.2)
                        continue

                    if trycount > 0 and trycause == "EqRow":
                        trycount = 0

                    if rownum >= playerRowLimit :
                        needSearch = True
                        break
            
                rownum=len(DRIVER.find_elements(by=By.XPATH, value="//table[@id='gamelist_inner']/tr"))
                
            print(str(rownum) + " games found")
            millisec2 = int(time.time() * 1000)
            gameStatsLoadTotalTime += (millisec2 - millisec1)

            gametable = DRIVER.find_element(by=By.XPATH, value="//table[@id='gamelist_inner']")

            prevTableIdSet = tableIdSet
            tableIdSet = set()
            rowcount = 0
            newELO = 0
            skipTable = True
            millisec1 = int(time.time() * 1000)
            
            for gamerow in gametable.find_elements(by=By.XPATH, value =".//tr"):
                
                rowcount += 1
                colcount = 0
                prevELO = newELO

                # unfortunately it takes 15-20 ms to find an element...

                # 1st column, 2nd 'a': table id (class: bga_link)
                #tableId = gamerow.find_element(by=By.XPATH, value =".//td[1]/a[2]").text.lstrip('#')
                tableId = gamerow.find_element(by=By.CLASS_NAME, value ="bga-link").text.lstrip('#')
                tableIdSet.add(tableId)

                if skipTable and tableId in prevTableIdSet:
                    print(tableId + " skipped")
                    continue

                skipTable = False
                
                # 2nd column, 1st div: end time
                gameEnd = gamerow.find_element(by=By.XPATH, value =".//td[2]/div[1]").text

                # examples of game end values:
                # 2024-09-24 at 22:51           2024.09.24 22:51
                # yesterday at 14:51            tegnap 14:51-kor
                # today at 13:00                ma 13:00-kor
                # 2 hours ago                   2 órája
                # one hour ago                  egy órával ezelőtt
                # 41 minutes ago                41 perce
                endDate = gameEnd.split()[0]
                endDate = endDate.replace("-", ".")

                if "avg" in subfunc_set :
                    timePos = gameEnd.find(':')
                    if timePos == -1 :
                        # For today, we consider all games as having finished at noon
                        endTime = "12:00"
                    else :
                        timePos -= 2
                        endTime = gameEnd[timePos:timePos+5]
                
                match endDate :
                    case "tegnap" | "yesterday":
                        endDate = (datetime.today() - timedelta(days=1)).strftime(dateFormat)
                    case _ :    
                        if len(endDate) < 3 or endDate[0].isalpha() :
                            # "20 minutes ago" / "today"
                            endDate = datetime.today().strftime(dateFormat)

                #print(endDate + " " + endTime)                

                if "avg" in subfunc_set :
                    endDateTime = datetime(int(endDate[0:4]), int(endDate[5:7]), int(endDate[8:10]), int(endTime[0:2]), int(endTime[3:5]))
                    endTst = datetime.timestamp(endDateTime)
                    #print(str(endDateTime) + " -> " + str(int(endTst)))
                
                endDateDT = datetime.strptime(endDate, dateFormat)
                if endDateDT < current_date :
                    current_date = endDateDT
                else :
                    pass

                if endDateDT > maxDateDT:
                    print(tableId + " skipped (out of period)")
                    continue
                

                # 4th column, 2nd div, 1st div, 2nd span: new ELO value (class: gamerank_value)
                try:
                    #newELOStr = gamerow.find_element(by=By.XPATH, value=".//td[4]/div[2]/div[1]/span[@class='gamerank_value ']").text
                    newELOStr = gamerow.find_element(by=By.CLASS_NAME, value="gamerank_value ").text
                except NoSuchElementException:
                    newELOStr = ""
                if newELOStr == "" :
                    newELO = 0    
                else:
                    newELO = int(newELOStr)
                    if lastELO == 0 :
                        lastELO = newELO
                        lastTable = tableId
                        lastDate = endDate
                        lastDateDT = endDateDT

                
                if newELO == 0:
                    unranked = True
                    newELO = prevELO
                else:
                    unranked = False

                # if this is the first game in the table then we add an extra item to help the calculation of the average ELO rating
                if len(tableList) == 0 and "avg" in subfunc_set:
                    tableSeq += 1
                    tableObj = tableClass(1000000 - tableSeq, tableId + "0", maxDateStr, maxTst, newELO, False, False, False, True)
                    tableList.append(tableObj)

                if endDateDT < minDateDT:
                    tableSeq += 1
                    tableObj = tableClass(1000000 - tableSeq, "1", minDateStr, minTst, newELO, False, False, False, True)
                    tableList.append(tableObj)
                    needSearch = False
                    
                    print(tableId + " and older games skipped (out of period)")
                    break

                tableSeq += 1
                tableNum += 1
                tableObj = tableClass(1000000 - tableSeq, tableId, endDate, endTst, newELO, unranked, False, False, False)
                tableList.append(tableObj)
                current_date = current_date + timedelta(days=1)


            millisec2 = int(time.time() * 1000)
            gameStatsProcTotalTime += (millisec2 - millisec1)

        tableList.sort(key=lambda x: x.seq, reverse=False)

        maxELO = 0
        maxELODate = ""
        maxELOTable = ""
        dayRecSeq = 0
        dayRecSeqs = set()
        prevDate = ""
        rankedNum = 0
        newRec = True

        for tableObj in tableList:
            if tableObj.endDate != prevDate :
                if dayRecSeq > 0 :
                    dayRecSeqs.add(dayRecSeq)
                    dayRecSeq = 0

            if not tableObj.unranked :
                if not tableObj.fake :
                    rankedNum += 1
                    
                #print(str(tableObj.newELO) + ": " + tableObj.endDate + ", " + str(tableObj.endTst) + ", " + str(tableObj.fake))
                if tableObj.newELO > maxELO :
                    tableObj.newRecord = True
                    maxELO = tableObj.newELO
                    maxELODate = tableObj.endDate
                    maxELOTable = tableObj.tableId
                    dayRecSeq = tableObj.seq
            prevDate = tableObj.endDate                

        if dayRecSeq > 0 :
            dayRecSeqs.add(dayRecSeq)

        for tableObj in tableList:
            if tableObj.seq in dayRecSeqs:
                tableObj.newRecByDay = True

        if "avg" in subfunc_set :
            firstObj = True
            avgSum = 0
            prevELO = 0
            for tableObj in tableList:
                if not tableObj.unranked :
                    if firstObj :
                        firstObj = False
                        firstTst = tableObj.endTst
                    else :
                        avgSum += prevELO * ( tableObj.endTst - prevTst )
                    prevTst = tableObj.endTst
                    prevELO = tableObj.newELO
            print("avgSum   = " + str(avgSum))
            print("firstTst = " + str(firstTst))
            print("lastTst  = " + str(tableObj.endTst))
            if tableObj.endTst - firstTst > 1 :
                avgELO = avgSum / (tableObj.endTst - firstTst)

        if "sheetproc" in subfunc_set :
            player.current_elo = lastELO
            player.last_table_date = lastDate
            if player.last_table_date and not player.last_table_date.endswith("."):
                player.last_table_date += "."

            if lastDateDT >= datetime.now() + timedelta(days=-1*INACTIVITY_DAYS):
                player.active = True
            else:
                player.active = False    
            
            player.last_table_id = lastTable
            newRec = False 
            if not player.top_elo or int(player.top_elo) < maxELO:  
                player.top_elo = str(maxELO)
                player.top_elo_table_id = maxELOTable
                player.top_elo_date = maxELODate
                newRec = True
                if not player.top_elo_date.endswith("."):
                    player.top_elo_date += "."
            player.status = 1    

        file_opened = False
        if player_file != "":
            f = open(player_file, "w", encoding="utf-8")
            file_opened = True

            f.write("Player: " + player_name + "\n")
            f.write("Game: " + game_name + "\n")
            if minDateDT != datetime.min :
                f.write("Start date of examination: " + minDateStr + "\n")
            if maxDateDT != datetime.max :
                f.write("End date of examination: " + maxDateStr + "\n")
            f.write("Examination started at " + startDT.strftime("%Y.%m.%d %H:%M:%S") + "\n")
            startDT = datetime.now()
            f.write("Examination finished at " + startDT.strftime("%Y.%m.%d %H:%M:%S") + "\n")
            f.write("\n")

        if maxDateDT != datetime.max or minDateDT != datetime.min :
            if tableNum > rankedNum:
                print("Number of games within the period: " + str(tableNum))
            print("Number of ranked games within the period: " + str(rankedNum))
            if newRec :
                print("Personal ELO record of " + player_name + " within the period:")
        else :    
            print("Number of games: " + str(tableNum))
            print("Number of ranked games: " + str(rankedNum))
            print("Personal ELO record of " + player_name + ":")
            print(maxELODate + ": " + str(maxELO))
        if "avg" in subfunc_set :
            print("Average ELO: " + str('{0:.2f}'.format(avgELO)))

        if file_opened :
            f.write("Number of ranked games: " + str(rankedNum) + "\n")
            if "avg" in subfunc_set :
                f.write("Average ELO: " + str('{0:.2f}'.format(avgELO)) + "\n")
            f.write("Highest ELO: " + str(maxELO) + " (" + maxELODate + ")\n")
            f.write("Final ELO: " + str(lastELO) + " \n")
            f.write("\n")

        if newRec :
            print()
            print("Days when " + player_name + " reached new personal ELO record:")

            if file_opened :
                f.write("ELO progress:\n")
                f.write("\n")
            
            for tableObj in tableList:
                if tableObj.newRecByDay :
                    endMark = " *" if tableObj.fake else ""
                        
                    print(tableObj.endDate + ": " + str(tableObj.newELO) + endMark)
                    if file_opened:
                        f.write(tableObj.endDate + ": " + str(tableObj.newELO) + endMark + "\n")

        if file_opened:
            f.close()
        print()

    end_millisec = int(time.time() * 1000)

    if "sheetproc" in subfunc_set :
        writesheet = True
        for player in players:
            if player.status == 2:
                if errorStr == "":
                    errorStr = "Error when processing player " + player.bga_name
                writesheet = False;
            if player.status == 0:
                if errorStr == "":
                    errorStr = "Unprocessed player: " + player.bga_name
                writesheet = False;
            print(f"{player.bga_name} ({player.bga_id}): {player.status}")
            print(f"last: {player.current_elo} at table {player.last_table_id} on {player.last_table_date}")
            print(f"best: {player.top_elo} at table {player.top_elo_table_id} on {player.top_elo_date}")
        if writesheet:
            sheet_utils.write_bga_elo(players)
        sheet_utils.write_meta_last_run(writesheet, errorStr)    

    if len(players) == 1:
        if tableSeq > 0:
            print("Average load time per game:    " + str('{0:.2f}'.format(gameStatsLoadTotalTime / tableSeq)) + " ms")
            print("Average process time per game: " + str('{0:.2f}'.format(gameStatsProcTotalTime / tableSeq)) + " ms")
    else:
        print("Average process time per player: " + str('{0:.2f}'.format((end_millisec - start_millisec) / len(players) )) + " ms")

    end_millisec = int(time.time() * 1000)
    print("Complete runtime: " + str(end_millisec - start_millisec) + " ms")
    
    time.sleep(1)

def trn_tablelistcoll( trns_file, # name of the input file containing tournament ids or links
                       outputfile_name = "" # concatenated output
                     ):

    filename_noext = "" 
    if not os.path.isfile(trns_file):
        filename_noext, extension = os.path.splitext(trns_file)
        input_dir = PATHS['input_dir']
        if os.path.isdir(input_dir):
            trns_file = input_dir + trns_file

    if not os.path.isfile(trns_file):
        print("File doesn't exist.")
        return


    print(f"Input: {trns_file}")

    trn_lines: List[str] = []
    trn_files: List[str] = []
    trn_code = ""
    trn_name = ""

    with open(trns_file, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line not in trn_lines:
                trn_lines.append(line)
    print(f"Number of trn lines: {len(trn_lines)}")

    for trn_line in trn_lines:
        if trn_line.startswith("##") :
            trn_code = trn_line[2:].strip()
            print(f"Tournament code: {trn_code}")
        elif trn_line.startswith("#") :   
            trn_name = trn_line[1:].strip()
            print(f"Tournament name: {trn_name}")
        else :
            match = re.search(r"(\d+)\s*$", trn_line)
            if match:
                trn_id = match.group(1)
            print(f"Tournament id {trn_id}")
            print(f"Tournament code {trn_code}")
            print(f"Tournament name {trn_name}")
            trn_file = trn_tablecoll(trn_id, file_name=".", trn_code=trn_code, trn_name=trn_name, output_subdir=filename_noext)
            print(f"Tournament file: {trn_file}")
            if trn_file != "" :
                trn_files.append(trn_file)

    if outputfile_name != "" :
        output_dir = PATHS['output_dir']
        if output_dir != "" :
            if os.path.isdir(output_dir):
                outputfile_name = os.path.join(output_dir, outputfile_name)
            else :
                print(output_dir + " does not exist")
    if outputfile_name != "" :
        print("Output file: " + outputfile_name)

        with open(outputfile_name, "w", encoding="utf-8") as outfile:
            for fname in trn_files:
                with open(fname, "r", encoding="utf-8") as infile:
                    outfile.write(infile.read())
    

def trn_tablecoll( trn_id,   # id of the tournament
                   file_name, # name of file to export data
                   trn_code = "", # forced code of the tournament
                   trn_name = "", # forced name of the tournament 
                   output_subdir = "" # subdirectory of the output files
                ):

    trn_file = ""
    if file_name == ".":
        trn_file = ("tournament_" + trn_id + ".lst")
    elif file_name != "":
        trn_file = file_name
    else :
        trn_file = ""
        
    output_dir = PATHS['output_dir']
    if trn_file != "" and output_dir != "" :
        if os.path.isdir(output_dir):
            if output_subdir != "":
                output_dir = os.path.join(output_dir, output_subdir)
                os.makedirs(output_dir, exist_ok=True)        
            #trn_file = output_dir + "/" + trn_file
            trn_file = os.path.join(output_dir, trn_file)
        else :
            print(output_dir + " does not exist")
    if trn_file != "" :
        print("Output file: " + trn_file)

    close_popup()

    # to get game stats we need to log in
    login()

    start_millisec = int(time.time() * 1000)
    
    trn_url = (BGA_DATA['urls']['tournament'].
                             replace('{p1}', trn_id))
    print(trn_url)

# div containing all games of the tournament:

# Swiss system:
# XPath:       //*[@id="stage_display"]/div/div/div[2]
# Full XPath:  /html/body/div[2]/div[5]/div[1]/div/div/div[4]/div/div/div/div/div[2]

# Round-robin (1 stage)
# XPath:       //*[@id="stage_display"]/div/div/div[2]
# Full XPath:  /html/body/div[2]/div[5]/div[1]/div/div/div[4]/div/div/div/div/div[2]

# Round-robin (2 stage):
# XPath:       //*[@id="stage_display"]/div/div/div/div[2]/div[3]/div[2]
# Full XPath:  /html/body/div[2]/div[5]/div[1]/div/div/div[4]/div/div/div/div/div/div[2]/div[3]/div[2]

# class of div containing all games:          v2tournament__encounters
# class of emelents containing link to games: v2tournament__encounter-title

    trycount = 0
    success = False
    while not success:
        try:
            if trycount == 0:
                DRIVER.get(trn_url)
            else:    
                DRIVER.refresh()
                print("refresh")
            elements = WAIT.until(EC.presence_of_all_elements_located((By.CLASS_NAME, "v2tournament__encounter-title")))
            
            success = True
        except TimeoutException:
            time.sleep(1)
            trycount += 1
            if trycount == 3:
                print("Cannot load tournament page.")
                exit_program()            

    print("Tournament page loaded.")

    table_ids = []

    for elem in elements:
        href = elem.get_attribute("href")
        if href:
            match = re.search(r"table=(\d+)", href)
            if match:
                table_ids.append(match.group(1))

    print("Number of games:" + str(len(table_ids)))

    file_opened = False
    if trn_file != "":
        try:
            f = open(trn_file, "w")
            file_opened = True

            if trn_code != "" :
                f.write("##" + trn_code + "\n")
            if trn_name != "" :
                f.write("#" + trn_name + "\n")

            for table_id in table_ids:
                f.write(table_id + "\n")
        except:
            print("Cannot write file " + trn_file)
        finally:    
            if file_opened:
                f.close()


    end_millisec = int(time.time() * 1000)

    print("Complete runtime: " + str(end_millisec - start_millisec) + " ms")
                  
    time.sleep(1)
    return trn_file


def tablelistproc( tables_file, # name of the input file containing table ids
                   output_subdir = "" # subdirectory of the output files
                 ):

    if not os.path.isfile(tables_file):
        input_dir = PATHS['input_dir']
        if os.path.isdir(input_dir):
            tables_file = input_dir + tables_file

    if not os.path.isfile(tables_file):
        print("File doesn't exist.")
        return

    print(f"Input: {tables_file}")


    if output_subdir == ".":
        output_subdir, extension = os.path.splitext(tables_file)
        
    if output_subdir != "":
        print("Output directory: " + output_subdir)

    table_codes: List[str] = []
    trn_code = ""
    trn_name = ""

    with open(tables_file, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line not in table_codes:
                table_codes.append(line)
    print(f"Number of tables: {len(table_codes)}")

    if "db" in subfunc_set :

        connection = None

        try:
            connection = get_connection()

            for table_code in table_codes:
                print("table_code")
                print(table_code)
                print(table_code.startswith("##"))
                if table_code.startswith("##") :
                    trn_code = table_code[2:].strip()
                    print(f"Tournament code: {trn_code}")
                elif table_code.startswith("#") :   
                    trn_name = table_code[1:].strip()
                    print(f"Tournament name: {trn_name}")
                else :
                    match = re.search(r"(\d+)\s*$", table_code)
                    if match:
                        table_code = match.group(1)
                    print(f"Table no. {table_code}")
                    tableproc(table_code, output_subdir, trn_code=trn_code, trn_name=trn_name, connection=connection)

        except Exception as e:
            print(f"Error: {e}")
            if connection:
                connection.rollback()
        finally:
            if connection :
                print("Closing database connection...")
                connection.close()

    else :
        for table_code in table_codes:
            print(f"Table no. {table_code}")
            tableproc(table_code, output_subdir)


def tableproc( table_code, # id of the table
               output_subdir = "", # subdirectory of the output files
               trn_code = "", # code of a non-BGA tournament
               trn_name = "", # name of a non-BGA tournament
               connection = None # optional database connection for saving data
             ):

    global lang
    global othlang

    if len(table_code) < 8 :
        print("Wrong table id: " + table_code)
        return

    if output_subdir == ".":
        output_subdir = table_code

    output_dir = "";
    if output_subdir != "":
        output_dir = PATHS['output_dir']
        if not os.path.isdir(output_dir):
            print(output_dir + " does not exist")
            exit_program()            
        
        output_dir = os.path.join(output_dir, output_subdir)
        os.makedirs(output_dir, exist_ok=True)        
    print(f"output directory: {output_dir}")
        
    close_popup()
    
    # to get game stats we need to log in
    login()

    start_millisec = int(time.time() * 1000)

            
    # requests are not suitable for collecting table data - the responses don't contain the relevant components
    # thus we have to use Selenium for this purpose as well
    
    table_url = (BGA_DATA['urls']['table'].replace('{p1}', table_code))
    #table_url = (BGA_DATA['urls']['gamereview'].replace('{p1}', table_code))
    print(table_url)

    trycount = 0
    success = False
    hasscore = False
    while not success:
        try:
            if trycount == 0:
                DRIVER.get(table_url)
            else:    
                DRIVER.refresh()
                print("Refresh")
            WAIT.until(EC.visibility_of_element_located((By.ID, "game_result_panel")))
            success = True
            
            WAIT.until(EC.visibility_of_element_located((By.CLASS_NAME, "score-entry")))
            hasscore = True
        except TimeoutException:
            if success :
                print("Game not played")
                return
            else :   
                time.sleep(1)
                trycount += 1
                if trycount == 3:
                    print("Cannot load table page.")
                    exit_program()            

    # relevant ids:
    # - div_id = tournament_link: optional, contains the link to a BGA tournament
    # - div id = gameoptions: game settings
    # - div id = game_result: player names and result of the game
    # - div id = statistics_content:
    #   - div id = table_stats
    #   - table id = player_stats_table

    gameoptions_div = DRIVER.find_element(By.ID, "gameoptions")

    tournament_inbga = False
    tournament_origname = ""
    
    if trn_code != "" :
        tournament_code = trn_code
    else :    
        tournament_code = ""

    if trn_name != "" :
        tournament_name = trn_name
    else :
        tournament_name = ""

    try:
        tournament_div = DRIVER.find_element(By.ID, "tournament_link")
        tournament_link = tournament_div.find_element(By.CSS_SELECTOR, "a.bga-link")
        href_value = tournament_link.get_attribute("href")
        match = re.search(r"id=(\d+)", href_value)
        if match:
            if tournament_code == "" :
                tournament_code = match.group(1)
            if trn_name != "" :
                tournament_origname = tournament_link.text
            else :
                tournament_name = tournament_link.text
                
            tournament_inbga = True

    except NoSuchElementException:
        pass

    print(f"code : {tournament_code}")
    print(f"name : {tournament_name}")
    print(f"origname : {tournament_origname}")

    tournamentObj = None
    playerObj1 = None
    playerObj2 = None
    
    if tournament_code == "" :
        print("Not a tournament game.")
        try:
            icon_arena_div = gameoptions_div.find_element(By.CLASS_NAME, "icon_arena")
            tournament_code = "100000"
            tournament_name = "Arena"
        except:
            pass

    if tournament_code != "" :
        tournamentObj = Tournament(code=tournament_code, name=tournament_name, inbga=tournament_inbga, origname=tournament_origname)
    
    result_div = DRIVER.find_element(By.XPATH, "//div[@id='game_result']")
    player_divs = result_div.find_elements(By.XPATH, "./div")

    seq = 0

    for player_div in player_divs:

        seq = seq + 1
        player_elem = player_div.find_element(By.XPATH, ".//a[@class='playername']")

        player_name = player_elem.text

        href_value = player_elem.get_attribute("href")
        match = re.search(r"id=(\d+)", href_value)
        player_code = ""
        if match:
            player_code = match.group(1)
        else:
            player_code = "N/A"

        score_div = player_div.find_element(By.XPATH, ".//div[@class='score']")
        try:
            player_score = int(score_div.get_attribute("textContent").split()[0])
        except ValueError:
            player_score = 0
        player_bgascore = player_score    
        winner = (player_score > 0 and seq == 1)

        hasrankdata = False
        try:
            newrank_span = player_div.find_element(By.XPATH, ".//span[@class='gamerank_value ']")
            hasrankdata = True
        except NoSuchElementException:
            pass

        player_newrank = 0  
        player_rankchg = 0

        if hasrankdata :
            try:
                player_newrank = newrank_span.get_attribute("textContent").split()[0]        
            except ValueError:
                pass

            winpt_span = player_div.find_element(By.XPATH, ".//span[starts-with(@id, 'winpoints_value')]")
            try:
                player_rankchg = winpt_span.get_attribute("textContent").split()[0]        
            except ValueError:
                pass

        player_outoftime = False
        try:
            clockpenalty_span = player_div.find_element(By.XPATH, ".//span[@class='clockpenalty']")
            style_value = clockpenalty_span.get_attribute("style")
            match = (re.search(r"display\s*:\s*inline", style_value))
            if match :
                player_outoftime = True
        except:
            pass

        if seq == 1 :
            tableplayerObj1 = TablePlayer(seq=1, player_code=player_code, table_code=table_code, score=player_score, bgascore=player_bgascore, newrank=player_newrank, rankchg=player_rankchg, winner=winner, outoftime=player_outoftime)
            playerObj1 = Player(code=player_code, name=player_name)
        else :   
            tableplayerObj2 = TablePlayer(seq=2, player_code=player_code, table_code=table_code, score=player_score, bgascore=player_bgascore, newrank=player_newrank, rankchg=player_rankchg, winner=winner, outoftime=player_outoftime)
            playerObj2 = Player(code=player_code, name=player_name)

    if playerObj2 is None :
        print("Player data not found for table: " + table_code)
        return

    if "winbyclock" in subfunc_set :
        if tableplayerObj1.outoftime :
            tableplayerObj1.winner = False
            tableplayerObj1.score = 0
            tableplayerObj2.winner = True
            tableplayerObj2.score = 1
        elif tableplayerObj2.outoftime :    
            tableplayerObj2.winner = False
            tableplayerObj2.score = 0
            tableplayerObj1.winner = True
            tableplayerObj1.score = 1

    stat_div = DRIVER.find_element(By.XPATH, "//div[@id='statistics_content']")
    tablestat_div = stat_div.find_element(By.XPATH, ".//div[@id='table_stats']")
    tablestatrow_divs = tablestat_div.find_elements(By.XPATH, "./div[@class='row-data']")

    table_duration = "" 
    table_width = 0 
    table_height = 0 
    table_ccities = ""

    DURATION_LABELS = {
        "hu": "Játékhossz",
        "en": "Game duration"
    }
    WIDTH_LABELS = {
        "hu": "Tábla szélessége",
        "en": "Board width"
    }
    HEIGHT_LABELS = {
        "hu": "Tábla magassága",
        "en": "Board height"
    }
    CCITIES_LABELS = {
        "hu": "Befejezett városok",
        "en": "Completed cities"
    }
    
    for tablestatrow_div in tablestatrow_divs:
        tablestatrow_label = tablestatrow_div.find_element(By.XPATH, "./div[@class='row-label']")
        tablestatrow_value = tablestatrow_div.find_element(By.XPATH, "./div[@class='row-value']")

        if tablestatrow_label.text == DURATION_LABELS[lang] :
            table_duration = tablestatrow_value.get_attribute("textContent").strip()
        elif tablestatrow_label.text == WIDTH_LABELS[lang] :    
            table_width = int(tablestatrow_value.get_attribute("textContent").strip())
        elif tablestatrow_label.text == HEIGHT_LABELS[lang] :    
            table_height = int(tablestatrow_value.get_attribute("textContent").strip())
        elif tablestatrow_label.text == CCITIES_LABELS[lang] :    
            table_ccities = int(tablestatrow_value.get_attribute("textContent").strip())

    tableObj = Table(tournament_code=tournament_code, code=table_code, game_code = "1", width=table_width, height=table_height, duration=table_duration, ccities=table_ccities)

    playerstattable = stat_div.find_element(By.XPATH, ".//table[@id='player_stats_table']")

    player1_time = player2_time = ""
    player1_roadpt = player2_roadpt = 0
    player1_citypt = player2_citypt = 0
    player1_monasterypt = player2_monasterypt = 0
    player1_fieldpt = player2_fieldpt = 0
    player1_meeples = player2_meeples = 0

    TIME_LABELS = {
        "hu": "Gondolkodási idő",
        "en": "Thinking time"
    }
    ROADPT_LABELS = {
        "hu": "Utakért kapott pontok",
        "en": "Points from roads"
    }
    CITYPT_LABELS = {
        "hu": "Városokért kapott pontok",
        "en": "Points from cities"
    }
    MONASTERYPT_LABELS = {
        "hu": "Kolostorokért kapott pontok",
        "en": "Points from monasteries"
    }
    FIELDPT_LABELS = {
        "hu": "Mezőkért kapott pontok",
        "en": "Points from fields"
    }
    MEEPLES_LABELS = {
        "hu": "Kijátszott alattvalók",
        "en": "Meeples placed"
    }

    for playerstatrow in playerstattable.find_elements(by=By.XPATH, value =".//tr"):
        playerstatrow_head = playerstatrow.find_element(By.XPATH, "./th")
        playerstatrow_cols = playerstatrow.find_elements(By.TAG_NAME, "td")
        if playerstatrow_cols :
        
            if playerstatrow_head.text == TIME_LABELS[lang] :
                player1_time = playerstatrow_cols[0].get_attribute("textContent").strip()
                player2_time = playerstatrow_cols[1].get_attribute("textContent").strip()
            elif playerstatrow_head.get_attribute("textContent") == ROADPT_LABELS[lang] :
                try:
                    player1_roadpt = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_roadpt = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass
            elif playerstatrow_head.get_attribute("textContent") == CITYPT_LABELS[lang] :
                try:
                    player1_citypt = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_citypt = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass
            elif playerstatrow_head.get_attribute("textContent") == MONASTERYPT_LABELS[lang] :
                try:
                    player1_monasterypt = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_monasterypt = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass
            elif playerstatrow_head.get_attribute("textContent") == FIELDPT_LABELS[lang] :
                try:
                    player1_fieldpt = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_fieldpt = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass
            elif playerstatrow_head.get_attribute("textContent") == MEEPLES_LABELS[lang] :
                try:
                    player1_meeples = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_meeples = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass

    tableplayerObj1.time,        tableplayerObj2.time        = player1_time,        player2_time
    tableplayerObj1.roadpt,      tableplayerObj2.roadpt      = player1_roadpt,      player2_roadpt 
    tableplayerObj1.citypt,      tableplayerObj2.citypt      = player1_citypt,      player2_citypt
    tableplayerObj1.monasterypt, tableplayerObj2.monasterypt = player1_monasterypt, player2_monasterypt
    tableplayerObj1.fieldpt,     tableplayerObj2.fieldpt     = player1_fieldpt,     player2_fieldpt 
    tableplayerObj1.meeples,     tableplayerObj2.meeples     = player1_meeples,     player2_meeples

    if not "skipreview" in subfunc_set :

        gamereview_url = (BGA_DATA['urls']['gamereview'].replace('{p1}', table_code))
        print(gamereview_url)

        trycount = 0
        success = False
        while not success:
            try:
                if trycount == 0:
                    DRIVER.get(gamereview_url)
                else:    
                    DRIVER.refresh()
                    print("Refresh")
                WAIT.until(EC.visibility_of_element_located((By.ID, "gamelogs")))
                success = True
            except TimeoutException:
                time.sleep(1)
                trycount += 1
                if trycount == 3:
                    print("Cannot load gamereview page.")
                    exit_program()            

        # it isn't necessary to click the checkbox: time logs are part of the DOM (but they're invisible due to display: none)
        #checkbox = DRIVER.find_element(By.ID, "display_time_on_logs")
        #if not checkbox.is_selected():
            #checkbox.click()

        time.sleep(1)

        gamelogs_div = DRIVER.find_element(By.XPATH, "//div[@id='gamelogs']")
        logrow_divs = gamelogs_div.find_elements(By.XPATH, "./div")
        if len(logrow_divs) == 0 :
            print("Cannot load gamereview data, probably reaching limit...")
            exit_program()

        print("Gamereview loaded")

        move_number = 0
        step_number = 1
        turn_number = 0

        step_player_pos = 0
        turn_player_pos = 0
        start_player_pos = 0
        
        step_desc = ""
        logstart = False
        bg_position = ""
        timeinfo = starttimeinfo = ""
        stepDate = stepTime = ""
        score = 0
        clock1 = clock2 = startclock = ""
        conceded = False
        
        carcevent : CarcEvent = CarcEvent.START
        carcfeature : CarcFeature = CarcFeature.VOID
        carctile : CarcTile = CarcTile.VOID

        carcsteps : List[CarcStep] = [] 
        carcstepObj = None

        CITY_KEYWORDS = {
            "hu": "város",
            "en": "city"
        }
        ROAD_KEYWORDS = {
            "hu": "út",
            "en": "road"
        }
        MONASTERY_KEYWORDS = {
            "hu": "kolostor",
            "en": "monastery"
        }
        ABBEY_KEYWORDS = {
            "hu": "kolostor",
            "en": "abbey"
        }
        FIELD_KEYWORDS = {
            "hu": "mező",
            "en": "field"
        }

        MEEPLE_KEYWORDS = {
            "hu": "alattval",
            "en": "meeple"
        }
        TILE_KEYWORDS = {
            "hu": "lerak egy",
            "en": "places a tile"
        }
        DISCARD_KEYWORDS = {
            "hu": "tudja",
            "en": "cannot"
        }
        COMPLETE_KEYWORDS = {
            "hu": "befejez",
            "en": "complete"
        }
        FINALFIELD_KEYWORDS = {
            "hu": "várost",
            "en": "adjacent"
        }
        POINTS_KEYWORDS = {
            "hu": "szerez",
            "en": "scores"
        }
        FINAL_KEYWORDS = {
            "hu": "fejezetlen",
            "en": "incomplete"
        }
        CONCEDE_KEYWORDS = {
            "hu": "feladja",
            "en": "concedes"
        }
        ABANDON_KEYWORDS = {
            "hu": "megszakítása",
            "en": "chose to abandon"
        }

        for logrow_div in logrow_divs:

            class_value = logrow_div.get_attribute("class")
            class_list = class_value.split()

            if "smalltext" in class_list:
                # Move 2
                
                match = re.search(r'\d+', logrow_div.text)
                if match:
                    move_number = int(match.group())
                
                spans = logrow_div.find_elements(By.TAG_NAME, "span")
                for span in spans:
                    timeinfo = span.text.strip()

                    full_timestamp_pattern = r"(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})\.\s*(\d{1,2}):(\d{2}):(\d{2})"
                    match = re.match(full_timestamp_pattern, timeinfo)
                    if match :
                        stepDate = match.group(1) + "." + match.group(2).zfill(2) + "." + match.group(3).zfill(2) + "."
                        stepTime = match.group(4).zfill(2) + ":" + match.group(5) + ":" + match.group(6)
                    else :
                        time_pattern = r"(\d{1,2}):(\d{2}):(\d{2})"
                        match = re.match(time_pattern, timeinfo)
                        if match :
                            stepTime = match.group(1).zfill(2) + ":" + match.group(2) + ":" + match.group(3)
                        else :
                            stepTime = timeinfo
                    timeinfo = (stepDate + " " + stepTime    ).strip()
                    
                    if starttimeinfo == "" :
                        starttimeinfo = timeinfo 

            if "gamelogreview" in class_list:

                if move_number == 1 :
                    continue

                score = 0
                step_desc = logrow_div.text.strip()
                step_desc = step_desc.replace("\n", " ").replace("\r", " ")
                needtile = False
                needfeature = False
                keepfeature = False

                player_pos = 0
                if step_desc.startswith(playerObj1.name) :
                    player_pos = 1
                elif step_desc.startswith(playerObj2.name) :    
                    player_pos = 2
                
                if MEEPLE_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.MEEPLE
                    needfeature = True
                elif TILE_KEYWORDS[lang] in step_desc :
                    if carcevent != CarcEvent.DISCARD :
                        turn_number = turn_number + 1
                    carcevent = CarcEvent.TILE
                    turn_player_pos = player_pos
                    step_player_pos = player_pos
                    if start_player_pos == 0 :
                        start_player_pos = player_pos
                    needtile = True
                    logstart = True
                elif DISCARD_KEYWORDS[lang] in step_desc :
                    if carcevent != CarcEvent.DISCARD :
                        carcevent = CarcEvent.DISCARD
                        turn_number = turn_number + 1
                    turn_player_pos = player_pos
                    step_player_pos = player_pos
                    needtile = True
                elif COMPLETE_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.COMPLETE
                    step_player_pos = player_pos
                    needfeature = True
                elif FINALFIELD_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.FINAL
                    carcfeature = CarcFeature.FIELD
                    keepfeature = True
                    step_player_pos = 0
                elif POINTS_KEYWORDS[lang] in step_desc :
                    match = re.search(r'(\d+)\s+(pont|point)', step_desc, re.IGNORECASE)
                    if match:
                        score = int(match.group(1))
                    else :
                        score = 0
                    carcevent = CarcEvent.POINTS
                    step_player_pos = player_pos
                    needfeature = True
                    keepfeature = True # keep the feature of the previous step
                elif FINAL_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.FINAL
                    step_player_pos = 0
                    needfeature = True
                elif CONCEDE_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.CONCEDE
                    turn_player_pos = player_pos
                    step_player_pos = player_pos
                    conceded = True
                elif ABANDON_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.ABANDON
                    turn_player_pos = player_pos
                    step_player_pos = player_pos
                else :
                    continue

                if not keepfeature :
                    carcfeature = CarcFeature.VOID
                    # BGA fordítási hiba miatt keressük a másik nyelvű szöveget is
                    if needfeature :
                        if CITY_KEYWORDS[lang] in step_desc or CITY_KEYWORDS[othlang] in step_desc :
                            carcfeature = CarcFeature.CITY
                        elif ROAD_KEYWORDS[lang] in step_desc or ROAD_KEYWORDS[othlang] in step_desc :
                            carcfeature = CarcFeature.ROAD
                        elif MONASTERY_KEYWORDS[lang] in step_desc or ABBEY_KEYWORDS[lang] in step_desc or MONASTERY_KEYWORDS[othlang] in step_desc or ABBEY_KEYWORDS[othlang] in step_desc:
                            carcfeature = CarcFeature.MONASTERY
                        elif FIELD_KEYWORDS[lang] in step_desc or FIELD_KEYWORDS[othlang] in step_desc :
                            carcfeature = CarcFeature.FIELD

                carctile = CarcTile.VOID
                if needtile :
                    try:
                        tile_art_div = logrow_div.find_element(By.CSS_SELECTOR, ".tile_art")
                        bg_position = tile_art_div.value_of_css_property("background-position")
                        carctile = get_carctile_by_bgpos(bg_position)
                    except:
                        pass

                step_number = step_number + 1
                carcstepObj = CarcStep(table_code=table_code, seq=step_number, turn=turn_number, bgamove=move_number, turnplayer=turn_player_pos, stepplayer=step_player_pos,
                                       event=carcevent, feature=carcfeature, tile=carctile, score=score, desc=step_desc, time=timeinfo, clock1="", clock2="")
                carcsteps.append(carcstepObj)


            if "reflexiontimes_block" in class_list:
                reflexion_divs = logrow_div.find_elements(By.CSS_SELECTOR, ".reflexiontimes")
                for reflexion_div in reflexion_divs:
                    reflexion_spans = reflexion_div.find_elements(By.TAG_NAME, "span")
                    for reflexion_span in reflexion_spans:
                        if carcstepObj != None :
                            if playerObj1.name in reflexion_div.get_attribute("textContent") :
                                carcstepObj.clock1 = reflexion_span.get_attribute("textContent").strip()
                                if startclock == "" and start_player_pos == 2 :
                                    startclock = carcstepObj.clock1;
                            elif playerObj2.name in reflexion_div.get_attribute("textContent") :
                                carcstepObj.clock2 = reflexion_span.get_attribute("textContent").strip()
                                if startclock == "" and start_player_pos == 1 :
                                    startclock = carcstepObj.clock2;

         
        print(f"No. of steps: {len(carcsteps)}")
        print(f"Move number: {move_number}")
        print(f"Player2 out of time: {tableplayerObj2.outoftime}")
        print(f"Player1 score: {tableplayerObj1.score}")
        
        if len(carcsteps) == 0 and move_number < 2 :
            print("Gamelog not available...")
            exit_program()            
            #return          
           
        carcevent = CarcEvent.START
        carcstepObj = CarcStep(table_code=table_code, seq=1, turn=1, bgamove=1, turnplayer=start_player_pos, stepplayer=start_player_pos,
                               event=carcevent, feature=CarcFeature.VOID, tile=CarcTile.VOID, score=0, desc="", time=starttimeinfo, clock1=startclock, clock2=startclock)
        carcsteps.append(carcstepObj)

        if tableplayerObj2.outoftime and tableplayerObj1.score == 1 and not conceded :
            step_number = step_number + 1
            carcevent = CarcEvent.TIMEOVER
            carcstepObj = CarcStep(table_code=table_code, seq=step_number, turn=turn_number, bgamove=move_number, turnplayer=turn_player_pos, stepplayer=turn_player_pos,
                                   event=carcevent, feature=CarcFeature.VOID, tile=CarcTile.VOID, score=0, desc="", time=timeinfo, clock1="", clock2="")
            carcsteps.append(carcstepObj)
            

        # post processing 1: filling missing clock values
        turnswithclock1 = set()
        turnswithclock2 = set()
        for carcstep in carcsteps:
            if carcstep.clock1 != "":
                turnswithclock1.add(carcstep.turn)
            if carcstep.clock2 != "":
                turnswithclock2.add(carcstep.turn)
        lastturn = 0

        for index in range(2):
            if index == 0:
                carcsteps.sort(key=lambda carcstep: -1*carcstep.seq)
            else:    
                carcsteps.sort(key=lambda carcstep: carcstep.seq)

            prevclock1 = ""
            prevclock2 = ""
            prevturn = 0

            for carcstep in carcsteps:
                if index == 0 and lastturn == 0:
                    lastturn = carcstep.turn
                
                if carcstep.clock1 == "" and carcstep.turn in turnswithclock1:
                    if carcstep.turn == prevturn and prevclock1 != "":
                        carcstep.clock1 = prevclock1
                if carcstep.clock2 == "" and carcstep.turn in turnswithclock2:
                    if carcstep.turn == prevturn and prevclock2 != "":
                        carcstep.clock2 = prevclock2

                if carcstep.clock1 == "" and not carcstep.turn in turnswithclock1:
                    if ((index == 0 and carcstep.turnplayer == 2) or (index == 1 and (carcstep.turnplayer == 1 or carcstep.turn == lastturn)) ) and prevclock1 != "":
                        carcstep.clock1 = prevclock1
                if carcstep.clock2 == "" and not carcstep.turn in turnswithclock2:
                    if ((index == 0 and carcstep.turnplayer == 1) or (index == 1 and (carcstep.turnplayer == 2 or carcstep.turn == lastturn)) ) and prevclock2 != "":
                        carcstep.clock2 = prevclock2

                prevclock1 = carcstep.clock1
                prevclock2 = carcstep.clock2
                prevturn = carcstep.turn

            
        if output_dir != "" :
           output_file = os.path.join(output_dir, "table_" + table_code + "_steps.csv")
           print("Writing steps to file: " + output_file)

           try:
               with open(output_file, "w", encoding="utf-8") as file:
                   line= "table_code|seq|turn|bgamove|turnplayer|stepplayer|event|feature|tile|score|desc|time|clock1|clock2\n"
                   file.write(line)
                   for carcstep in carcsteps:
                       line = f"{carcstep.table_code}|{carcstep.seq}|{carcstep.turn}|{carcstep.bgamove}|{carcstep.turnplayer}|{carcstep.stepplayer}|{carcstep.event.value}|"\
                              f"{carcstep.feature.value}|{carcstep.tile.value}|{carcstep.score}|{carcstep.desc}|{carcstep.time}|{carcstep.clock1}|{carcstep.clock2}\n" 
                       file.write(line)
               print("Done")
           except Exception as e:
               print(f"Error: {e}")       
         

    if "db" in subfunc_set :
        needcloseconn = False
        print("Saving data")

        try:
            if connection is None :
                connection = get_connection()
                needcloseconn = True

            cursor = connection.cursor()
 
            # tournament 
            if not tournamentObj is None :
                
                cursor.execute("SELECT tournament_id FROM tournament WHERE code = ?", (tournamentObj.code,))
                row = cursor.fetchone()
                if row:
                    tournamentObj.id = row[0]
                else:
                    cursor.execute("INSERT INTO tournament (code, name, inbga, origname) VALUES (?, ?, ?, ?)", 
                                   (tournamentObj.code, tournamentObj.name, tournamentObj.inbga, tournamentObj.origname))
                    tournamentObj.id = cursor.lastrowid
                tableObj.tournament_id = tournamentObj.id    

            # table
            cursor.execute("SELECT table_id FROM table_ WHERE code = ?", (tableObj.code,))
            row = cursor.fetchone()
            if row:
                tableObj.id = row[0]
                cursor.execute("UPDATE table_ SET tournament_id = ?, game_code = ?, width = ?, height = ?, duration = ?, ccities = ? WHERE table_id = ?", 
                               (tableObj.tournament_id, tableObj.game_code, tableObj.width, tableObj.height, tableObj.duration, tableObj.ccities, tableObj.id))
            else:
                cursor.execute("INSERT INTO table_ (tournament_id, code, game_code, width, height, duration, ccities) VALUES (?, ?, ?, ?, ?, ?, ?)", 
                               (tableObj.tournament_id, tableObj.code, tableObj.game_code, tableObj.width, tableObj.height, tableObj.duration, tableObj.ccities))
                tableObj.id = cursor.lastrowid

            # players, tableplayers
            for i in range(2):
                if i == 0 :
                    playerObj = playerObj1
                    tableplayerObj = tableplayerObj1
                else :   
                    playerObj = playerObj2
                    tableplayerObj = tableplayerObj2
                
                cursor.execute("SELECT player_id FROM player WHERE code = ?", (playerObj.code,))
                row = cursor.fetchone()
                if row:
                    playerObj.id = row[0]
                else:
                    cursor.execute("INSERT INTO player (code, name) VALUES (?, ?)", 
                                   (playerObj.code, playerObj.name))
                    playerObj.id = cursor.lastrowid

                tableplayerObj.player_id = playerObj.id
                tableplayerObj.table_id = tableObj.id

                cursor.execute("SELECT tableplayer_id FROM tableplayer WHERE table_id = ? AND player_id = ?", 
                               (tableplayerObj.table_id, tableplayerObj.player_id))
                row = cursor.fetchone()
                if row:
                    tableplayerObj.id = row[0]
                    cursor.execute("UPDATE tableplayer SET seq = ?, score = ?, bgascore = ?, newrank = ?, rankchg = ?, winner = ?, roadpt = ?, citypt = ?, monasterypt = ?, fieldpt = ?, meeples = ?, time = ?, outoftime = ? WHERE tableplayer_id = ?", 
                                   (tableplayerObj.seq, tableplayerObj.score, tableplayerObj.bgascore, tableplayerObj.newrank, tableplayerObj.rankchg, tableplayerObj.winner,
                                    tableplayerObj.roadpt, tableplayerObj.citypt, tableplayerObj.monasterypt, tableplayerObj.fieldpt, tableplayerObj.meeples, 
                                    tableplayerObj.time, tableplayerObj.outoftime, tableplayerObj.id))
                else:
                    cursor.execute("INSERT INTO tableplayer (table_id, player_id, seq, score, bgascore, newrank, rankchg, winner, roadpt, citypt, monasterypt, fieldpt, meeples, time, outoftime) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", 
                                   (tableplayerObj.table_id, tableplayerObj.player_id, tableplayerObj.seq, tableplayerObj.score, tableplayerObj.bgascore, tableplayerObj.newrank, tableplayerObj.rankchg, tableplayerObj.winner,
                                    tableplayerObj.roadpt, tableplayerObj.citypt, tableplayerObj.monasterypt, tableplayerObj.fieldpt, tableplayerObj.meeples, tableplayerObj.time, tableplayerObj.outoftime))
                    tableplayerObj.id = cursor.lastrowid

            # carcsteps
            if not "skipreview" in subfunc_set :
                cursor.execute("SELECT COUNT(*) FROM carcstep WHERE table_id = ?", (tableObj.id,))
                count = cursor.fetchone()[0]

                if count > 0:
                    cursor.execute("DELETE FROM carcstep WHERE table_id = ?", (tableObj.id,))
            
                for carcstepObj in carcsteps:
                    carcstepObj.table_id = tableObj.id
                    cursor.execute("INSERT INTO carcstep (table_id, seq, turn, bgamove, turnplayer, stepplayer, event, feature, tile, score, desc, time, clock1, clock2) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                                   (carcstepObj.table_id, carcstepObj.seq, carcstepObj.turn, carcstepObj.bgamove, carcstepObj.turnplayer, carcstepObj.stepplayer,
                                    carcstepObj.event, carcstepObj.feature, carcstepObj.tile, carcstepObj.score, carcstepObj.desc, carcstepObj.time, carcstepObj.clock1, carcstepObj.clock2))                
                    carcstepObj.id = cursor.lastrowid

            connection.commit()

        except Exception as e:
            print(f"Error: {e}")
            if connection:
                connection.rollback()
        finally:
            if needcloseconn :
                print("Closing database connection")
                connection.close()

    end_millisec = int(time.time() * 1000)

    print("Complete runtime: " + str(end_millisec - start_millisec) + " ms")


loggedIn = False
popupClosed = False
lang = "hu"
othlang = "en"

# 1st param.: function to call
argnum = len(sys.argv)

if argnum > 1 :
    func = sys.argv[1]
else :
    func = 'elo_hist'

table_id = ""
trn_id = ""
game_def = ""
player_names = ""
file_name = ""
outputfile_name = ""
output_dir = ""
min_date = ""
max_date = ""
trn_code = ""
trn_name = ""
subfunc_set = set()
headless = False
no_sandbox = False
update_profilepic = False

LOG_DIR = PATHS.get("log_dir")
if LOG_DIR:
    LOG_DIR = Path(LOG_DIR)
    LOG_DIR.mkdir(parents = True, exist_ok = True)

    logfile_name = LOG_DIR / f"{func}_{datetime.now():%Y-%m-%d}.log"
    logfile = open(logfile_name, "a", encoding="utf-8", buffering=1)

    sys.stdout = logfile
    sys.stderr = logfile

    print("="*80)
    print(f"START: {datetime.now().isoformat(sep=' ', timespec='seconds')}")
    print(" ")
    
if argnum > 2 :
    for argpos in range(2, argnum):
        if argpos == argnum - 1 and sys.argv[argpos][:2] != '--':
            break
            
        match sys.argv[argpos]:
            case "-t":
                trn_id = sys.argv[argpos + 1]
            case "-b":
                table_id = sys.argv[argpos + 1]
            case "-g":
                game_def = sys.argv[argpos + 1]
            case "-p":
                player_names = sys.argv[argpos + 1]
            case "-f":
                file_name = sys.argv[argpos + 1]
            case "-of":
                outputfile_name = sys.argv[argpos + 1]
            case "-o":
                output_dir = sys.argv[argpos + 1]
            case "-mn":
                min_date = sys.argv[argpos + 1]
            case "-mx":
                max_date = sys.argv[argpos + 1]
            case "-tc":
                trn_code = sys.argv[argpos + 1]
            case "-tn":
                trn_name = sys.argv[argpos + 1]
            case "--sheetproc":
                subfunc_set.add("sheetproc")
            case "--avg":
                subfunc_set.add("avg")
            case "--db":
                subfunc_set.add("db")
            case "--reset":
                subfunc_set.add("reset")
            case "--skipreview":
                subfunc_set.add("skipreview")
            case "--winbyclock":
                subfunc_set.add("winbyclock")
            case "--headless":
                headless = True
            case "--no-sandbox":
                no_sandbox = True
            case "--profilepic":
                update_profilepic = True

try:
    DRIVER, WAIT = create_driver(headless=headless, no_sandbox=no_sandbox)                

    if "sheetproc" in subfunc_set:
        players = sheet_utils.read_players()
        link_icon = sheet_utils.read_meta_value("bga_link_icon")
        if link_icon:
            print(f"Link icon: {link_icon}")
            for p in players:
                p.linkicon = link_icon
                
    else:
        print("game: " + game_def + ", player: " + player_names + ", file: " + file_name)            
        players: List[PlayerELO] = []
        for player_name in player_names.split(","):
            player_name = player_name.strip()
            players.append(PlayerELO(
                bga_name = player_name
            ))    
    print(f"no of players: {len(players)}")

    match func :
        case "elo_hist":
            elo_hist(game_def, players, min_date, max_date, file_name, update_profilepic)
        case "login":    
            login()
        case "init_db":    
            init_db()
        case "trn_tablelistcoll":
            trn_tablelistcoll(file_name, outputfile_name)
        case "trn_tablecoll":
            trn_tablecoll(trn_id, file_name)
        case "carc_tablelistproc":
            tablelistproc(file_name, output_dir)
        case "carc_tableproc":
            tableproc(table_id, output_dir, trn_code=trn_code, trn_name=trn_name)
        case _:
            print("unknown function")

finally:
    if DRIVER is not None:
        try:
            DRIVER.quit()
        except Exception:
            pass
        
if LOG_DIR:
    print(" ")
    print(f"END: {datetime.now().isoformat(sep=' ', timespec='seconds')}")
    print(" ")
 

# BGA_Scraping.py
# Python program to get data from BGA

import time
import sys
import yaml
import re
import os.path
import sqlite3

from config import PATHS, BGA_LOGIN, BGA_DATA, DRIVER, WAIT
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum
from typing import Optional
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import ElementClickInterceptedException
from selenium.common.exceptions import TimeoutException

# terminology:
# game = the type of board game
# table = one particular match of a given game
class tableClass :
    def __init__(self,seq,tableId,endDate,endTst,newELO,unranked,newRecord,newRecByDay,fake):
        self.seq = seq
        self.tableId = tableId
        self.endDate = endDate
        self.endTst = endTst
        self.newELO = newELO
        self.unranked = unranked
        self.newRecord = newRecord
        self.newRecByDay = newRecByDay
        self.fake = fake

class CarcEvent(str, Enum):
    START= "S"
    TILE = "T"
    MEEPLE = "M"
    COMPLETE = "C"
    FINAL = "F"
    POINTS = "P"
    DISCARD = "D"
    CONCEDE = "X"
    ABANDON = "A"
    TIMEOVER = "O"

class CarcFeature(str, Enum):
    ROAD = "R"
    CITY = "C"
    MONASTERY = "M"
    FIELD = "F"
    VOID = ""

class CarcTile(str, Enum):
    FFFF  = "FFFF"
    RFFF  = "RFFF"
    RFRF  = "RFRF"
    RRFF  = "RRFF"
    RRRF  = "RRRF"
    RRRR  = "RRRR"
    CFFF  = "CFFF"
    CRFR  = "CRFR"
    CFRR  = "CFRR"
    CRRF  = "CRRF"
    CRRR  = "CRRR"
    CFCF  = "CFCF"
    CFCFP = "CFCFp"
    CFCFS = "CFCFs"
    CCFF  = "CCFF"
    CCFFP = "CCFFp"
    CCFFS = "CCFFs"
    CCRR  = "CCRR"
    CCRRP = "CCRRp"
    CCCF  = "CCCF"
    CCCFP = "CCCFp"
    CCCR  = "CCCR"
    CCCRP = "CCCRp"
    CCCCP = "CCCCp"
    VOID  = ""

CARC_TILES_ROW1 = ["CCCR", "CCCRp","CCCRp","CCFF", "CCFF", "CCFF", "CCFFp","CCFFp","CCRR", "CCRR", "CCRR", "CCRRp","CCRRp","CFCF", "CFCFp","CFCFp"]
CARC_TILES_ROW2 = ["CCFFs","CCFFs","CFCFs","CFCFs","CFCFs","CFFF", "CFFF", "CFFF", "CFFF", "CFFF", "CFRR", "CFRR", "CFRR", "CRRF", "CRRF", "CRRF" ]
CARC_TILES_ROW3 = ["CRRR", "CRRR", "CRRR", "CRFR", "CRFR", "CRFR", "CRFR", "RFRF", "RFRF", "RFRF", "RFRF", "RFRF", "RFRF", "RFRF", "RFRF", "RRFF" ]
CARC_TILES_ROW4 = ["RRFF", "RRFF", "RRFF", "RRFF", "RRFF", "RRFF", "RRFF", "RRFF", "RRRF", "RRRF", "RRRF", "RRRF", "RRRR", "FFFF", "FFFF", "FFFF" ]
CARC_TILES_ROW5 = ["FFFF", "RFFF", "RFFF", "CCCCp","CCCF", "CCCF", "CCCF", "CCCFp","FFFF", "FFFF", "FFFF", "FFFF", "FFFF", "FFFF", "FFFF", "FFFF" ]


# dataclasses for saving data to DB
@dataclass
class Tournament:
    code: str
    name: str
    inbga: bool
    id: Optional[int] = None # auto-generated by DBMS

@dataclass
class Table:
    tournament_code: str # NONPERSISTENT
    code: str
    game_code: int
    width: int
    height: int
    duration: str
    ccities: int
    id: Optional[int] = None # auto-generated by DBMS
    tournament_id: int = 0 # link to a tournament
    
@dataclass
class Player:
    code: str
    name: str
    id: Optional[int] = None # auto-generated by DBMS

@dataclass
class TablePlayer:
    seq: int # unique within a table
    table_code: str # NONPERSISTENT
    player_code: str # NONPERSISTENT
    score: int
    newrank: int
    rankchg: int
    winner: bool
    outoftime: bool
    time: str = ""
    roadpt: int = 0
    citypt: int = 0
    monasterypt: int = 0
    fieldpt: int = 0
    meeples: int = 0
    id: Optional[int] = None # auto-generated by DBMS
    table_id: int = 0 # link to a table
    player_id: int = 0 # link to a player

@dataclass
class CarcStep:
    table_code: str # NONPERSISTENT
    seq: int
    turn: int
    bgamove: int # move number according to BGA
    turnplayer: int # which player's turn; refers to TablePlayer.seq
    stepplayer: int # which player's step (e.g. who's getting points); refers to TablePlayer.seq; 0 = final scoring
    event: CarcEvent
    feature: CarcFeature # in case of MEEPLE, COMPLETE or POINTS event
    tile: CarcTile # in case of TILE or DISCARD event
    score: int
    desc: str
    time: str # 2025. 03. 03. 1:07:06 -> 2025.03.03. 01:07:06
    clock1: str
    clock2: str
    id: Optional[int] = None # auto-generated by DBMS
    table_id: int = 0 # link to a table

def exit_program():
    print("Exiting...")
    sys.exit(0)

def close_popup():
    global popupClosed
    if popupClosed :
        return        

    # We open the main page just to dismiss popups if there's any
    mainpage_link = BGA_DATA['urls']['main']
    DRIVER.get(mainpage_link)
    try:
        popup = WAIT.until(EC.element_to_be_clickable((By.XPATH, "//div[contains(@class, 'cc-window')]//a[contains(@class, 'cc-btn')]")))
        popup.click()
        print("Popup closed")
    except TimeoutException:
        print("No clickable popup found")
    popupClosed = True    

def login24():
    # Deprecated login method
    login_link = BGA_DATA['urls']['login']
    print(login_link);
    DRIVER.get(login_link)

    username = BGA_LOGIN['user']
    pw = BGA_LOGIN['password']

    WAIT.until(EC.visibility_of_element_located((By.ID, "username_input")))
    it_username = DRIVER.find_element(By.ID, "username_input")
    it_username.send_keys(username)

    WAIT.until(EC.visibility_of_element_located((By.ID, "password_input")))
    password = DRIVER.find_element(By.ID, "password_input")
    password.send_keys(pw)

    WAIT.until(EC.visibility_of_element_located((By.ID, "submit_login_button")))
    DRIVER.find_element(By.ID, "submit_login_button").click()

def login():
    global loggedIn
    global lang
    
    if loggedIn :
        return        

    login_link = BGA_DATA['urls']['login']
    print(login_link);
    DRIVER.get(login_link)

    username = BGA_LOGIN['user']
    pw = BGA_LOGIN['password']

    WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[1]/div/div[2]/form/div[2]/div/input')))
    it_username = DRIVER.find_element(By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[1]/div/div[2]/form/div[2]/div/input')

    it_username.send_keys(username)
    time.sleep(2)

    WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[1]/div/div[2]/form/div[3]/div/a')))
    DRIVER.find_element(By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[1]/div/div[2]/form/div[3]/div/a').click()
    time.sleep(1)

    WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[2]/div/form/div[1]/div[2]/div/input')))
    it_password = DRIVER.find_element(By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[2]/div/form/div[1]/div[2]/div/input')
    it_password.send_keys(pw)
    time.sleep(2)

    WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[2]/div/form/div[2]/div/div/a')))
    DRIVER.find_element(By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[2]/div/form/div[2]/div/div/a').click()

    time.sleep(1)

    WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[3]/div[2]/div[3]/div[3]/div/div/a')))
    DRIVER.find_element(By.XPATH, '//*[@id="account-module"]/div[3]/div[3]/div/div[2]/div/div[2]/div[3]/div[2]/div[3]/div[3]/div/div/a').click()
    time.sleep(1)
    loggedIn = True
    print("login successful")

    forumlink = DRIVER.find_element(By.XPATH, "//a[contains(@href, 'forum')]")
    print(forumlink.text)
    if forumlink.text.upper() == 'FORUMS' :
        lang = "en"
    print(lang)

def init_db():

    db_path = PATHS['db_path']

    if os.path.isdir(db_path):
        print(f"Database file name missing: {db_path}")
        return

    if os.path.exists(db_path) and not "reset" in subfunc_set :
        print(f"Database file already exists: {db_path}")
        return

    db_dir = os.path.dirname(db_path)
    if not os.path.exists(db_dir):
        print(f"Directory does not exist: {db_dir}")
        return

    try:

        connection = sqlite3.connect(db_path)
        cursor = connection.cursor()

        if "reset" in subfunc_set :
            cursor.execute("""
            DROP TABLE IF EXISTS tournament
            """)
            print("Table 'tournament' dropped")
            cursor.execute("""
            DROP TABLE IF EXISTS table_
            """)
            print("Table 'table_' dropped")
            cursor.execute("""
            DROP TABLE IF EXISTS player
            """)
            print("Table 'player' dropped")
            cursor.execute("""
            DROP TABLE IF EXISTS tableplayer
            """)
            print("Table 'tableplayer' dropped")
            cursor.execute("""
            DROP TABLE IF EXISTS carcstep
            """)
            print("Table 'carcstep' dropped")

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS tournament (
            tournament_id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            name TEXT NOT NULL,           -- WTCOC25 - Group 1 - FIN-HUN / TCF - FIN-HUN 2025-03-09
            inbga BOOLEAN NOT NULL CHECK (inbga IN (0, 1))
        )
        """)
        print("Table 'tournament' created")

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS table_ (
            table_id INTEGER PRIMARY KEY AUTOINCREMENT,
            tournament_id INTEGER NOT NULL,
            code TEXT UNIQUE NOT NULL,
            game_code TEXT NOT NULL,
            width INTEGER,
            height INTEGER,
            duration TEXT,
            ccities INTEGER,
            FOREIGN KEY (tournament_id) REFERENCES tournament(tournament_id)
        )
        """)
        print("Table 'table_' created")

        cursor.execute("""
        CREATE INDEX idx_table_trn_id ON table_(tournament_id)
        """)
        print("Index 'idx_table_trn_id' created")
    
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS player (
            player_id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            name TEXT UNIQUE NOT NULL
        )
        """)
        print("Table 'player' created")

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS tableplayer (
            tableplayer_id INTEGER PRIMARY KEY AUTOINCREMENT,
            table_id INTEGER NOT NULL,
            player_id INTEGER NOT NULL,
            seq INTEGER NOT NULL,
            score INTEGER NOT NULL,
            newrank INTEGER NOT NULL,
            rankchg INTEGER NOT NULL,
            roadpt INTEGER NOT NULL,
            citypt INTEGER NOT NULL,
            monasterypt INTEGER NOT NULL,
            fieldpt INTEGER NOT NULL,
            meeples INTEGER NOT NULL,
            time TEXT NOT NULL,
            winner BOOLEAN NOT NULL CHECK (winner IN (0, 1)),
            outoftime BOOLEAN NOT NULL CHECK (outoftime IN (0, 1)),
            FOREIGN KEY (table_id) REFERENCES table_(table_id),
            FOREIGN KEY (player_id) REFERENCES player(player_id)
        )
        """)
        print("Table 'tableplayer' created")

        cursor.execute("""
        CREATE UNIQUE INDEX idx_tableplayer_tbl_id ON tableplayer(table_id, player_id)
        """)
        print("Index 'idx_tableplayer_tbl_id' created")
        cursor.execute("""
        CREATE INDEX idx_tableplayer_pyr_id ON tableplayer(player_id)
        """)
        print("Index 'idx_tableplayer_pyr_id' created")

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS carcstep (
            carcstep_id INTEGER PRIMARY KEY AUTOINCREMENT,
            table_id INTEGER NOT NULL,
            seq INTEGER NOT NULL,
            turn INTEGER NOT NULL,
            bgamove INTEGER NOT NULL,
            turnplayer INTEGER NOT NULL,
            stepplayer INTEGER NOT NULL,
            event TEXT NOT NULL,
            feature TEXT,
            tile TEXT,
            score INTEGER,
            desc TEXT,
            time TEXT,
            clock1 TEXT,
            clock2 TEXT,
            FOREIGN KEY (table_id) REFERENCES table_(table_id)
        )
        """)
        print("Table 'carcstep' created")

        cursor.execute("""
        CREATE UNIQUE INDEX idx_carcstep_tbl_id ON carcstep(table_id, seq)
        """)
        print("Index 'idx_carcstep_tbl_id' created")

        connection.commit()

    except Exception as e:
        print(f"Error: {e}")
        if connection:
            connection.rollback()
    finally:
        if connection :
            print("Closing database connection...")
            connection.close()

def get_carctile_by_bgpos(bg_position):

    carctile: CarcTile = CarcTile.VOID
    match = re.search(r'\s*(\d+)(?:\.\d+)?%\s+(\d+)(?:\.\d+)?%', bg_position)
    if match:
        x_pos = int(match.group(1))
        y_pos = int(match.group(2))

        #X values: 0, 6, 13, 20, 26, 33, 40, 46, 53, 60, 66, 73, 80, 86, 93, 100
        #Y values: 0, 11, 22, 33, 44

        col = 0
        tilestr = ""
        match x_pos :
            case  0 : col = 1
            case  6 : col = 2   
            case 13 : col = 3   
            case 20 : col = 4   
            case 26 : col = 5   
            case 33 : col = 6   
            case 40 : col = 7   
            case 46 : col = 8   
            case 53 : col = 9   
            case 60 : col = 10   
            case 66 : col = 11   
            case 73 : col = 12   
            case 80 : col = 13   
            case 86 : col = 14   
            case 93 : col = 15   
            case 100 : col = 16   
        match y_pos :
            case 0 : tilestr = CARC_TILES_ROW1[col - 1]
            case 11 : tilestr = CARC_TILES_ROW2[col - 1]
            case 22 : tilestr = CARC_TILES_ROW3[col - 1]
            case 33 : tilestr = CARC_TILES_ROW4[col - 1]
            case 44 : tilestr = CARC_TILES_ROW5[col - 1]

        if tilestr != "" :
            carctile = CarcTile(tilestr)
        else :
            print(f"x: {x_pos}, y: {y_pos}")

    if carctile == CarcTile.VOID :
        print("Tile cannot be identified.")

    return carctile   
        
    
def get_connection():

    db_path = PATHS['db_path']
    if not os.path.exists(db_path):
        print(f"Database file does not exists: {db_path}")
        return None

    print("Database file: " + db_path)
    return sqlite3.connect(db_path)


def elo_hist( game_def,     # id or name of the game,
              player_names, # the players' BGA name separated by comma
              min_date,     # start of the period to check (no limit if empty)
              max_date,     # end of the period to check (no limit if empty)
              file_name,    # name of file to export data
            ):

    global lang

    ROW_LIMIT = 200

    maxDateStr = ""
    minDateStr = ""
    maxDateDT = datetime.max
    minDateDT = datetime.min
    
    maxTst = None
    minTst = None

    if max_date != "":
        maxDateStr = max_date.replace("-", ".")
        try:
            maxDateDT = datetime.strptime(maxDateStr, '%Y.%m.%d')
        except ValueError as e:
            print("End of period is not a proper date value (YYYY-MM-DD)")
            exit_program()
        #time.mktime(maxDateTime.timetuple())
    else :
        if "avg" in subfunc_set :
            maxDateStr = datetime.today().strftime('%Y.%m.%d')
    if maxDateStr != "" :
        maxTstDT = datetime(int(maxDateStr[0:4]), int(maxDateStr[5:7]), int(maxDateStr[8:10]), 12, 0)
        maxTst = datetime.timestamp(maxTstDT)

    print("maxDate = " + maxDateStr + "    maxTst = " + str(maxTst))        

    if min_date != "":
        minDateStr = min_date.replace("-", ".")
        try:
            minDateDT = datetime.strptime(minDateStr, '%Y.%m.%d')
        except ValueError as e:
            print("Start of period is not a proper date value (YYYY-MM-DD)")
            exit_program()
            
        minTstDT = datetime(int(minDateStr[0:4]), int(minDateStr[5:7]), int(minDateStr[8:10]), 0, 0)
        minTst = datetime.timestamp(minTstDT)
        #time.mktime(minDateTime.timetuple())

    print("minDate = " + minDateStr + "    minTst = " + str(minTst))        

    game_name = 'unknown'
    game_id = '0'
    if game_def != "" :
        for k, v in BGA_DATA['gameids'].items():
            if game_def.upper().replace(" ", "").replace("_", "") == k.upper().replace(" ", "").replace("_", "") or game_def == str(v) :
                game_id = str(v)
                game_name = k
    else :
        game_id = '1'
        game_name = 'Carcassonne'

    if game_id == '0' :
        print("Unknown game")
        exit_program()
        
    print(game_id + " - " + game_name)
        
    if player_names == "" :
        player_names = BGA_LOGIN['user']
    
    if minDateDT != datetime.min :
        print('Start date: %s' % (minDateStr))
    if maxDateDT != datetime.max :
        print('End date: %s' % (maxDateStr))

    close_popup()

    # we need the player's id in BGA
    # to get the community page we need to log in
    login()
    time.sleep(1)

    gameStatsLoadTotalTime = 0
    gameStatsProcTotalTime = 0

    start_millisec = int(time.time() * 1000)

    for player_name in player_names.split(","):
        player_name = player_name.strip()
        print('ELO progress of %s in the game %s:' % (player_name, game_name))

        if file_name == ".":
            player_file = (player_name + "__" + game_name).lower().replace(" ", "_") + ".elo"
        elif file_name != "":
            player_file = file_name
        else :
            player_file = ""
            
        output_dir = PATHS['output_dir']
        if player_file != "" and output_dir != "" :
            if os.path.isdir(output_dir):
                player_file = output_dir + player_file
            else :
                print(output_dir + " does not exist")
        if player_file != "" :
            print("Output file: " + player_file)
        print()

        community_link = BGA_DATA['urls']['community']
        DRIVER.get(community_link)
        time.sleep(1)

        WAIT.until(EC.visibility_of_element_located((By.ID, "findplayer")))
        it_findplayer = DRIVER.find_element(By.ID, "findplayer")
        it_findplayer.send_keys(player_name)
        it_findplayer.send_keys(Keys.ENTER)

        try:
            WAIT.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="elo_game_' + game_id + '"]')))
        except TimeoutException:
            print("Player %s has not played the game %s yet." % (player_name, game_name))
            continue

        player_url = DRIVER.current_url
        print("The current url is: " + str(player_url))

        player_id = player_url[(player_url.find('='))+1:]
        print("Player id is: " + player_id)    

        startDT = datetime.now()

        if maxDateDT != datetime.max :
            current_date = maxDateDT + timedelta(days=1)
        else :   
            current_date = startDT + timedelta(days=1)

        needSearch = True
        tableSeq = 0
        tableNum = 0
        tableIdSet = {}
        tableList = []
        endTst = None
        dateFormat = "%Y.%m.%d"
        
        while needSearch :
            # convert date to lixux timestamp
            unix_timestamp = datetime.timestamp(current_date)
            end_timestamp = str(int(unix_timestamp))

            gamestats_url = (BGA_DATA['urls']['gamestatsfull'].
                             replace('{p1}', player_id).
                             replace('{p2}', game_id).
                             replace('{p3}', '0').
                             replace('{p4}', end_timestamp))
            print(gamestats_url)

            millisec1 = int(time.time() * 1000)
            
            trycount = 0
            needSearch = False
            success = False
            while not success:
                try:
                    if trycount == 0:
                        DRIVER.get(gamestats_url)
                    else:    
                        DRIVER.refresh()
                        print("refresh")
                    WAIT.until(EC.visibility_of_element_located((By.XPATH, "//table[@id='gamelist_inner']")))
                    success = True
                except TimeoutException:
                    time.sleep(1)
                    trycount += 1
                    if trycount == 3:
                        print("Cannot load gamestat page.")
                        exit_program()            

            #print("Gamestats page loaded.")

            rownum = len(DRIVER.find_elements(by=By.XPATH, value="//table[@id='gamelist_inner']/tr"))
            time.sleep(0.5)

            trycount = 0
            trycause = ""

            # pressing "more tables" until the number of games doesn't increase any more or the number of rows reaches 100
            while trycount < 4:
                prev_rownum = rownum

                footer = DRIVER.find_element(By.ID, "overall-footer")
                location = footer.location_once_scrolled_into_view
                ##footer.sendKeys(Keys.END);

                WAIT.until(EC.visibility_of_element_located((By.XPATH, '//a[@class="bga-link"][@id="see_more_tables"]')))
                WAIT.until(EC.element_to_be_clickable((By.XPATH, '//a[@class="bga-link"][@id="see_more_tables"]')))
                
                link = DRIVER.find_element(By.XPATH, '//a[@class="bga-link"][@id="see_more_tables"]')

                #success = False
                #while not success:
                try:
                    link.click()
                    #success = True
                    if trycount > 0 and trycause == "Click":
                        trycount = 0
                except ElementClickInterceptedException:
                    print("ElementClickInterceptedException. Trycount=" + str(trycount))
                    trycount += 1
                    if trycount == 4 and trycause == "Click":
                        print("Cannot click 'More tables' button.")
                        exit_program()            

                    trycause = "Click"
                    time.sleep(trycount * 0.2)
                    continue

                time.sleep(0.05)

                WAIT.until(EC.visibility_of_element_located((By.XPATH, "//table[@id='gamelist_inner']")))
                rownum=len(DRIVER.find_elements(by=By.XPATH, value="//table[@id='gamelist_inner']/tr"))

                if prev_rownum == rownum:
                    trycount += 1
                    trycause = "EqRow"
                    time.sleep(trycount * 0.2)
                    continue

                if trycount > 0 and trycause == "EqRow":
                    trycount = 0

                if rownum >= ROW_LIMIT :
                    needSearch = True
                    break
            
            rownum=len(DRIVER.find_elements(by=By.XPATH, value="//table[@id='gamelist_inner']/tr"))
            print(str(rownum) + " games found")
            millisec2 = int(time.time() * 1000)
            gameStatsLoadTotalTime += (millisec2 - millisec1)

            gametable = DRIVER.find_element(by=By.XPATH, value="//table[@id='gamelist_inner']")

            prevTableIdSet = tableIdSet
            tableIdSet = set()
            rowcount = 0
            newELO = 0
            skipTable = True
            millisec1 = int(time.time() * 1000)
            
            for gamerow in gametable.find_elements(by=By.XPATH, value =".//tr"):
                
                rowcount += 1
                colcount = 0
                prevELO = newELO

                # unfortunately it takes 15-20 ms to find an element...

                # 1st column, 2nd 'a': table id (class: bga_link)
                #tableId = gamerow.find_element(by=By.XPATH, value =".//td[1]/a[2]").text.lstrip('#')
                tableId = gamerow.find_element(by=By.CLASS_NAME, value ="bga-link").text.lstrip('#')
                tableIdSet.add(tableId)

                if skipTable and tableId in prevTableIdSet:
                    print(tableId + " skipped")
                    continue

                skipTable = False
                
                # 2nd column, 1st div: end time
                gameEnd = gamerow.find_element(by=By.XPATH, value =".//td[2]/div[1]").text

                # 4th column, 2nd div, 1st div, 2nd span: nem ELO value (class: gamerank_value)
                try:
                    #newELOStr = gamerow.find_element(by=By.XPATH, value=".//td[4]/div[2]/div[1]/span[@class='gamerank_value ']").text
                    newELOStr = gamerow.find_element(by=By.CLASS_NAME, value="gamerank_value ").text
                except NoSuchElementException:
                    newELOStr = ""
                if newELOStr == "" :
                    newELO = 0    
                else:
                    newELO = int(newELOStr)

                # examples of game end values:
                # 2024-09-24 at 22:51           2024.09.24 22:51
                # yesterday at 14:51            tegnap 14:51-kor
                # today at 13:00                ma 13:00-kor
                # 2 hours ago                   2 órája
                # one hour ago                  egy órával ezelőtt
                # 41 minutes ago                41 perce
                endDate = gameEnd.split()[0]
                endDate = endDate.replace("-", ".")

                if "avg" in subfunc_set :
                    timePos = gameEnd.find(':')
                    if timePos == -1 :
                        # For today, we consider all games as having finished at noon
                        endTime = "12:00"
                    else :
                        timePos -= 2
                        endTime = gameEnd[timePos:timePos+5]
                
                match endDate :
                    case "tegnap" | "yesterday":
                        endDate = (datetime.today() - timedelta(days=1)).strftime(dateFormat)
                    case _ :    
                        if len(endDate) < 3 or endDate[0].isalpha() :
                            # "20 minutes ago" / "today"
                            endDate = datetime.today().strftime(dateFormat)

                #print(endDate + " " + endTime)                

                if "avg" in subfunc_set :
                    endDateTime = datetime(int(endDate[0:4]), int(endDate[5:7]), int(endDate[8:10]), int(endTime[0:2]), int(endTime[3:5]))
                    endTst = datetime.timestamp(endDateTime)
                    #print(str(endDateTime) + " -> " + str(int(endTst)))
                
                endDateDT = datetime.strptime(endDate, dateFormat)
                if endDateDT < current_date :
                    current_date = endDateDT
                else :
                    pass

                if endDateDT > maxDateDT:
                    print(tableId + " skipped (out of period)")
                    continue
                
                if newELO == 0:
                    unranked = True
                    newELO = prevELO
                else:
                    unranked = False

                # if this is the first game in the table then we add an extra item to help the calculation of the average ELO rating
                if len(tableList) == 0 and "avg" in subfunc_set:
                    tableSeq += 1
                    tableObj = tableClass(1000000 - tableSeq, tableId + "0", maxDateStr, maxTst, newELO, False, False, False, True)
                    tableList.append(tableObj)

                if endDateDT < minDateDT:
                    tableSeq += 1
                    tableObj = tableClass(1000000 - tableSeq, "1", minDateStr, minTst, newELO, False, False, False, True)
                    tableList.append(tableObj)
                    needSearch = False
                    
                    print(tableId + " and older games skipped (out of period)")
                    break

                tableSeq += 1
                tableNum += 1
                tableObj = tableClass(1000000 - tableSeq, tableId, endDate, endTst, newELO, unranked, False, False, False)
                tableList.append(tableObj)
                current_date = current_date + timedelta(days=1)


            print(str(tableNum) + " games total")
            millisec2 = int(time.time() * 1000)
            gameStatsProcTotalTime += (millisec2 - millisec1)

        tableList.sort(key=lambda x: x.seq, reverse=False)

        maxELO = 0
        maxELODate = ""
        dayRecSeq = 0
        dayRecSeqs = set()
        prevDate = ""
        rankedNum = 0

        for tableObj in tableList:
            if tableObj.endDate != prevDate :
                if dayRecSeq > 0 :
                    dayRecSeqs.add(dayRecSeq)
                    dayRecSeq = 0

            if not tableObj.unranked :
                if not tableObj.fake :
                    rankedNum += 1
                    
                #print(str(tableObj.newELO) + ": " + tableObj.endDate + ", " + str(tableObj.endTst) + ", " + str(tableObj.fake))
                if tableObj.newELO > maxELO :
                    tableObj.newRecord = True
                    maxELO = tableObj.newELO
                    maxELODate = tableObj.endDate
                    dayRecSeq = tableObj.seq
            prevDate = tableObj.endDate                

        if dayRecSeq > 0 :
            dayRecSeqs.add(dayRecSeq)

        for tableObj in tableList:
            if tableObj.seq in dayRecSeqs:
                tableObj.newRecByDay = True

        if "avg" in subfunc_set :
            firstObj = True
            avgSum = 0
            prevELO = 0
            for tableObj in tableList:
                if not tableObj.unranked :
                    if firstObj :
                        firstObj = False
                        firstTst = tableObj.endTst
                    else :
                        avgSum += prevELO * ( tableObj.endTst - prevTst )
                    prevTst = tableObj.endTst
                    prevELO = tableObj.newELO
            print("avgSum   = " + str(avgSum))
            print("firstTst = " + str(firstTst))
            print("lastTst  = " + str(tableObj.endTst))
            if tableObj.endTst - firstTst > 1 :
                avgELO = avgSum / (tableObj.endTst - firstTst)


        file_opened = False
        if player_file != "":
            f = open(player_file, "w")
            file_opened = True

            f.write("Player: " + player_name + "\n")
            f.write("Game: " + game_name + "\n")
            if minDateDT != datetime.min :
                f.write("Start date of examination: " + minDateStr + "\n")
            if maxDateDT != datetime.max :
                f.write("End date of examination: " + maxDateStr + "\n")
            f.write("Examination started at " + startDT.strftime("%Y.%m.%d %H:%M:%S") + "\n")
            startDT = datetime.now()
            f.write("Examination finished at " + startDT.strftime("%Y.%m.%d %H:%M:%S") + "\n")
            f.write("\n")

        print()
        if maxDateDT != datetime.max or minDateDT != datetime.min :
            print("Number of ranked games within the period: " + str(rankedNum))
            print("Personal ELO record of " + player_name + " within the period:")
        else :    
            print("Number of ranked games: " + str(rankedNum))
            print("Personal ELO record of " + player_name + ":")
        print(maxELODate + ": " + str(maxELO))
        if "avg" in subfunc_set :
            print("Average ELO: " + str('{0:.2f}'.format(avgELO)))

        if file_opened :
            f.write("Number of ranked games: " + str(rankedNum) + "\n")
            if "avg" in subfunc_set :
                f.write("Average ELO: " + str('{0:.2f}'.format(avgELO)) + "\n")
            f.write("Highest ELO: " + str(maxELO) + " (" + maxELODate + ")\n")
            f.write("\n")

        print()
        print("Days when " + player_name + " reached new personal ELO record:")

        if file_opened :
            f.write("ELO progress:\n")
            f.write("\n")
        
        for tableObj in tableList:
            if tableObj.newRecByDay :
                endMark = " *" if tableObj.fake else ""
                    
                print(tableObj.endDate + ": " + str(tableObj.newELO) + endMark)
                if file_opened:
                    f.write(tableObj.endDate + ": " + str(tableObj.newELO) + endMark + "\n")

        if file_opened:
            f.close()
        print()

    end_millisec = int(time.time() * 1000)
    print("Average load time per game:    " + str('{0:.2f}'.format(gameStatsLoadTotalTime / tableSeq)) + " ms")
    print("Average process time per game: " + str('{0:.2f}'.format(gameStatsProcTotalTime / tableSeq)) + " ms")
    print("Complete runtime: " + str(end_millisec - start_millisec) + " ms")
    
    time.sleep(1)

def trn_tablecoll( trn_id,   # id of the tournament
                   file_name # name of file to export data
                ):

    trn_file = ""
    if file_name == ".":
        trn_file = ("tournament_" + trn_id + ".lst")
    elif file_name != "":
        trn_file = file_name
    else :
        trn_file = ""
        
    output_dir = PATHS['output_dir']
    if trn_file != "" and output_dir != "" :
        if os.path.isdir(output_dir):
            trn_file = output_dir + trn_file
        else :
            print(output_dir + " does not exist")
    if trn_file != "" :
        print("Output file: " + trn_file)

    close_popup()

    # to get game stats we need to log in
    login()

    start_millisec = int(time.time() * 1000)
    
    trn_url = (BGA_DATA['urls']['tournament'].
                             replace('{p1}', trn_id))
    print(trn_url)

# div containing all games of the tournament:

# Swiss system:
# XPath:       //*[@id="stage_display"]/div/div/div[2]
# Full XPath:  /html/body/div[2]/div[5]/div[1]/div/div/div[4]/div/div/div/div/div[2]

# Round-robin (1 stage)
# XPath:       //*[@id="stage_display"]/div/div/div[2]
# Full XPath:  /html/body/div[2]/div[5]/div[1]/div/div/div[4]/div/div/div/div/div[2]

# Round-robin (2 stage):
# XPath:       //*[@id="stage_display"]/div/div/div/div[2]/div[3]/div[2]
# Full XPath:  /html/body/div[2]/div[5]/div[1]/div/div/div[4]/div/div/div/div/div/div[2]/div[3]/div[2]

# class of div containing all games:          v2tournament__encounters
# class of emelents containing link to games: v2tournament__encounter-title

    trycount = 0
    success = False
    while not success:
        try:
            if trycount == 0:
                DRIVER.get(trn_url)
            else:    
                DRIVER.refresh()
                print("refresh")
            elements = WAIT.until(EC.presence_of_all_elements_located((By.CLASS_NAME, "v2tournament__encounter-title")))
            
            success = True
        except TimeoutException:
            time.sleep(1)
            trycount += 1
            if trycount == 3:
                print("Cannot load tournament page.")
                exit_program()            

    print("Tournament page loaded.")

    table_ids = []

    for elem in elements:
        href = elem.get_attribute("href")
        if href:
            match = re.search(r"table=(\d+)", href)
            if match:
                table_ids.append(match.group(1))

    print("Number of games:" + str(len(table_ids)))

    file_opened = False
    if trn_file != "":
        try:
            f = open(trn_file, "w")
            file_opened = True

            for table_id in table_ids:
                f.write(table_id + "\n")
        except:
            print("Cannot write file " + trn_file)
        finally:    
            if file_opened:
                f.close()


    end_millisec = int(time.time() * 1000)

    print("Complete runtime: " + str(end_millisec - start_millisec) + " ms")
                  
    time.sleep(1)


def tablelistproc( tables_file, # name of the input file containing table ids
                   output_subdir = "" # subdirectory of the output files
                 ):

    if not os.path.isfile(tables_file):
        input_dir = PATHS['input_dir']
        if os.path.isdir(input_dir):
            tables_file = input_dir + tables_file

    if not os.path.isfile(tables_file):
        print("File doesn't exist.")
        return

    print(f"Input: {tables_file}")


    if output_subdir == ".":
        output_subdir, extension = os.path.splitext(tables_file)
        
    if output_subdir != "":
        print("Output directory: " + output_subdir)

    table_codes: List[str] = []
    trn_code = ""
    trn_name = ""

    with open(tables_file, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line not in table_codes:
                table_codes.append(line)
    print(f"Number of tables: {len(table_codes)}")

    if "db" in subfunc_set :

        connection = None

        try:
            connection = get_connection()

            for table_code in table_codes:
                if table_code.startswith("##") :
                    trn_code = table_code[2:].strip()
                    print(f"Tournament code: {trn_code}")
                elif table_code.startswith("#") :   
                    trn_name = table_code[1:].strip()
                    print(f"Tournament name: {trn_name}")
                else :
                    match = re.search(r"(\d+)\s*$", table_code)
                    if match:
                        table_code = match.group(1)
                    print(f"Table no. {table_code}")
                    tableproc(table_code, output_subdir, trn_code=trn_code, trn_name=trn_name, connection=connection)

        except Exception as e:
            print(f"Error: {e}")
            if connection:
                connection.rollback()
        finally:
            if connection :
                print("Closing database connection...")
                connection.close()

    else :
        for table_code in table_codes:
            print(f"Table no. {table_code}")
            tableproc(table_code, output_subdir)


def tableproc( table_code, # id of the table
               output_subdir = "", # subdirectory of the output files
               trn_code = "", # code of a non-BGA tournament
               trn_name = "", # name of a non-BGA tournament
               connection = None # optional database connection for saving data
             ):

    global lang

    if len(table_code) < 8 :
        print("Wrong table id: " + table_code)
        return

    if output_subdir == ".":
        output_subdir = table_code

    output_dir = "";
    if output_subdir != "":
        output_dir = PATHS['output_dir']
        if not os.path.isdir(output_dir):
            print(output_dir + " does not exist")
            exit_program()            
        
        output_dir = os.path.join(output_dir, output_subdir)
        os.makedirs(output_dir, exist_ok=True)        
    print(f"output directory: {output_dir}")
        
    close_popup()
    
    # to get game stats we need to log in
    login()

    start_millisec = int(time.time() * 1000)

    # requests are not suitable for collecting table data - the responses don't contain the relevant components
    # thus we have to use Selenium for this purpose as well
    
    table_url = (BGA_DATA['urls']['table'].replace('{p1}', table_code))
    #table_url = (BGA_DATA['urls']['gamereview'].replace('{p1}', table_code))
    print(table_url)

    trycount = 0
    success = False
    while not success:
        try:
            if trycount == 0:
                DRIVER.get(table_url)
            else:    
                DRIVER.refresh()
                print("Refresh")
            #WAIT.until(EC.visibility_of_element_located((By.ID, "gametable_box")))
            WAIT.until(EC.visibility_of_element_located((By.CLASS_NAME, "score-entry")))
            success = True
        except TimeoutException:
            time.sleep(1)
            trycount += 1
            if trycount == 3:
                print("Cannot load table page.")
                exit_program()            

    # relevant ids:
    # - div_id = tournament_link: optional, contains the link to a BGA tournament
    # - div id = gameoptions: game settings
    # - div id = game_result: player names and result of the game
    # - div id = statistics_content:
    #   - div id = table_stats
    #   - table id = player_stats_table

    gameoptions_div = DRIVER.find_element(By.ID, "gameoptions")

    tournament_code = ""
    tournament_name = ""
    tournament_inbga = False
    
    if trn_code != "" and trn_name != "" :
        tournament_code = trn_code
        tournament_name = trn_name
    else :
        try:
            tournament_div = DRIVER.find_element(By.ID, "tournament_link")
            tournament_link = tournament_div.find_element(By.CSS_SELECTOR, "a.bga-link")
            href_value = tournament_link.get_attribute("href")
            match = re.search(r"id=(\d+)", href_value)
            if match:
                tournament_code = match.group(1)
                tournament_name = tournament_link.text
                tournament_inbga = True

        except NoSuchElementException:
            pass

    tournamentObj = None
    playerObj1 = None
    playerObj2 = None
    
    if tournament_code == "" :
        print("Not a tournament game.")
        try:
            icon_arena_div = gameoptions_div.find_element(By.CLASS_NAME, "icon_arena")
            tournament_code = "100000"
            tournament_name = "Arena"
        except:
            pass

    if tournament_code != "" :
        tournamentObj = Tournament(code=tournament_code, name=tournament_name, inbga=tournament_inbga)
    
    result_div = DRIVER.find_element(By.XPATH, "//div[@id='game_result']")
    player_divs = result_div.find_elements(By.XPATH, "./div")

    seq = 0

    for player_div in player_divs:

        seq = seq + 1
        player_elem = player_div.find_element(By.XPATH, ".//a[@class='playername']")

        player_name = player_elem.text

        href_value = player_elem.get_attribute("href")
        match = re.search(r"id=(\d+)", href_value)
        player_code = ""
        if match:
            player_code = match.group(1)
        else:
            player_code = "N/A"

        score_div = player_div.find_element(By.XPATH, ".//div[@class='score']")
        try:
            player_score = int(score_div.get_attribute("textContent").split()[0])
        except ValueError:
            player_score = 0  
        winner = (player_score > 0 and seq == 1)

        hasrankdata = False
        try:
            newrank_span = player_div.find_element(By.XPATH, ".//span[@class='gamerank_value ']")
            hasrankdata = True
        except NoSuchElementException:
            pass

        player_newrank = 0  
        player_rankchg = 0

        if hasrankdata :
            try:
                player_newrank = newrank_span.get_attribute("textContent").split()[0]        
            except ValueError:
                pass

            winpt_span = player_div.find_element(By.XPATH, ".//span[starts-with(@id, 'winpoints_value')]")
            try:
                player_rankchg = winpt_span.get_attribute("textContent").split()[0]        
            except ValueError:
                pass

        player_outoftime = False
        try:
            clockpenalty_span = player_div.find_element(By.XPATH, ".//span[@class='clockpenalty']")
            style_value = clockpenalty_span.get_attribute("style")
            match = (re.search(r"display\s*:\s*inline", style_value))
            if match :
                player_outoftime = True
        except:
            pass

        if seq == 1 :
            tableplayerObj1 = TablePlayer(seq=1, player_code=player_code, table_code=table_code, score=player_score, newrank=player_newrank, rankchg=player_rankchg, winner=winner, outoftime=player_outoftime)
            playerObj1 = Player(code=player_code, name=player_name)
        else :   
            tableplayerObj2 = TablePlayer(seq=2, player_code=player_code, table_code=table_code, score=player_score, newrank=player_newrank, rankchg=player_rankchg, winner=winner, outoftime=player_outoftime)
            playerObj2 = Player(code=player_code, name=player_name)

    if playerObj2 is None :
        print("Player data not found for table: " + table_code)
        return

    stat_div = DRIVER.find_element(By.XPATH, "//div[@id='statistics_content']")
    tablestat_div = stat_div.find_element(By.XPATH, ".//div[@id='table_stats']")
    tablestatrow_divs = tablestat_div.find_elements(By.XPATH, "./div[@class='row-data']")

    table_duration = "" 
    table_width = 0 
    table_height = 0 
    table_ccities = ""

    DURATION_LABELS = {
        "hu": "Játékhossz",
        "en": "Game duration"
    }
    WIDTH_LABELS = {
        "hu": "Tábla szélessége",
        "en": "Board width"
    }
    HEIGHT_LABELS = {
        "hu": "Tábla magassága",
        "en": "Board height"
    }
    CCITIES_LABELS = {
        "hu": "Befejezett városok",
        "en": "Completed cities"
    }
    
    for tablestatrow_div in tablestatrow_divs:
        tablestatrow_label = tablestatrow_div.find_element(By.XPATH, "./div[@class='row-label']")
        tablestatrow_value = tablestatrow_div.find_element(By.XPATH, "./div[@class='row-value']")

        if tablestatrow_label.text == DURATION_LABELS[lang] :
            table_duration = tablestatrow_value.get_attribute("textContent").strip()
        elif tablestatrow_label.text == WIDTH_LABELS[lang] :    
            table_width = int(tablestatrow_value.get_attribute("textContent").strip())
        elif tablestatrow_label.text == HEIGHT_LABELS[lang] :    
            table_height = int(tablestatrow_value.get_attribute("textContent").strip())
        elif tablestatrow_label.text == CCITIES_LABELS[lang] :    
            table_ccities = int(tablestatrow_value.get_attribute("textContent").strip())

    tableObj = Table(tournament_code=tournament_code, code=table_code, game_code = "1", width=table_width, height=table_height, duration=table_duration, ccities=table_ccities)

    playerstattable = stat_div.find_element(By.XPATH, ".//table[@id='player_stats_table']")

    player1_time = player2_time = ""
    player1_roadpt = player2_roadpt = 0
    player1_citypt = player2_citypt = 0
    player1_monasterypt = player2_monasterypt = 0
    player1_fieldpt = player2_fieldpt = 0
    player1_meeples = player2_meeples = 0

    TIME_LABELS = {
        "hu": "Gondolkodási idő",
        "en": "Thinking time"
    }
    ROADPT_LABELS = {
        "hu": "Utakért kapott pontok",
        "en": "Points from roads"
    }
    CITYPT_LABELS = {
        "hu": "Városokért kapott pontok",
        "en": "Points from cities"
    }
    MONASTERYPT_LABELS = {
        "hu": "Kolostorokért kapott pontok",
        "en": "Points from monasteries"
    }
    FIELDPT_LABELS = {
        "hu": "Mezőkért kapott pontok",
        "en": "Points from fields"
    }
    MEEPLES_LABELS = {
        "hu": "Kijátszott alattvalók",
        "en": "Meeples placed"
    }

    for playerstatrow in playerstattable.find_elements(by=By.XPATH, value =".//tr"):
        playerstatrow_head = playerstatrow.find_element(By.XPATH, "./th")
        playerstatrow_cols = playerstatrow.find_elements(By.TAG_NAME, "td")
        if playerstatrow_cols :
        
            if playerstatrow_head.text == TIME_LABELS[lang] :
                player1_time = playerstatrow_cols[0].get_attribute("textContent").strip()
                player2_time = playerstatrow_cols[1].get_attribute("textContent").strip()
            elif playerstatrow_head.get_attribute("textContent") == ROADPT_LABELS[lang] :
                try:
                    player1_roadpt = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_roadpt = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass
            elif playerstatrow_head.get_attribute("textContent") == CITYPT_LABELS[lang] :
                try:
                    player1_citypt = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_citypt = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass
            elif playerstatrow_head.get_attribute("textContent") == MONASTERYPT_LABELS[lang] :
                try:
                    player1_monasterypt = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_monasterypt = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass
            elif playerstatrow_head.get_attribute("textContent") == FIELDPT_LABELS[lang] :
                try:
                    player1_fieldpt = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_fieldpt = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass
            elif playerstatrow_head.get_attribute("textContent") == MEEPLES_LABELS[lang] :
                try:
                    player1_meeples = int(playerstatrow_cols[0].get_attribute("textContent").strip())
                    player2_meeples = int(playerstatrow_cols[1].get_attribute("textContent").strip())
                except ValueError:
                    pass

    tableplayerObj1.time,        tableplayerObj2.time        = player1_time,        player2_time
    tableplayerObj1.roadpt,      tableplayerObj2.roadpt      = player1_roadpt,      player2_roadpt 
    tableplayerObj1.citypt,      tableplayerObj2.citypt      = player1_citypt,      player2_citypt
    tableplayerObj1.monasterypt, tableplayerObj2.monasterypt = player1_monasterypt, player2_monasterypt
    tableplayerObj1.fieldpt,     tableplayerObj2.fieldpt     = player1_fieldpt,     player2_fieldpt 
    tableplayerObj1.meeples,     tableplayerObj2.meeples     = player1_meeples,     player2_meeples

    if not "skipreview" in subfunc_set :

        gamereview_url = (BGA_DATA['urls']['gamereview'].replace('{p1}', table_code))
        print(gamereview_url)

        trycount = 0
        success = False
        while not success:
            try:
                if trycount == 0:
                    DRIVER.get(gamereview_url)
                else:    
                    DRIVER.refresh()
                    print("Refresh")
                WAIT.until(EC.visibility_of_element_located((By.ID, "gamelogs")))
                success = True
            except TimeoutException:
                time.sleep(1)
                trycount += 1
                if trycount == 3:
                    print("Cannot load gamereview page.")
                    exit_program()            

        # it isn't necessary to click the checkbox: time logs are part of the DOM (but they're invisible due to display: none)
        #checkbox = DRIVER.find_element(By.ID, "display_time_on_logs")
        #if not checkbox.is_selected():
            #checkbox.click()

        time.sleep(1)

        gamelogs_div = DRIVER.find_element(By.XPATH, "//div[@id='gamelogs']")
        logrow_divs = gamelogs_div.find_elements(By.XPATH, "./div")
        if len(logrow_divs) == 0 :
            print("Cannot load gamereview data, probably reaching limit...")
            exit_program()

        print("Gamereview loaded")

        move_number = 0
        step_number = 1
        turn_number = 0

        step_player_pos = 0
        turn_player_pos = 0
        start_player_pos = 0
        
        step_desc = ""
        logstart = False
        bg_position = ""
        timeinfo = starttimeinfo = ""
        stepDate = stepTime = ""
        score = 0
        clock1 = clock2 = startclock = ""
        conceded = False
        
        carcevent : CarcEvent = CarcEvent.START
        carcfeature : CarcFeature = CarcFeature.VOID
        carctile : CarcTile = CarcTile.VOID

        carcsteps : List[CarcStep] = [] 
        carcstepObj = None

        CITY_KEYWORDS = {
            "hu": "város",
            "en": "city"
        }
        ROAD_KEYWORDS = {
            "hu": "út",
            "en": "road"
        }
        MONASTERY_KEYWORDS = {
            "hu": "kolostor",
            "en": "monastery"
        }
        FIELD_KEYWORDS = {
            "hu": "mező",
            "en": "field"
        }

        MEEPLE_KEYWORDS = {
            "hu": "alattval",
            "en": "meeple"
        }
        TILE_KEYWORDS = {
            "hu": "lerak egy",
            "en": "places a tile"
        }
        DISCARD_KEYWORDS = {
            "hu": "tudja",
            "en": "cannot"
        }
        COMPLETE_KEYWORDS = {
            "hu": "befejez",
            "en": "complete"
        }
        FINALFIELD_KEYWORDS = {
            "hu": "várost",
            "en": "adjacent"
        }
        POINTS_KEYWORDS = {
            "hu": "szerez",
            "en": "scores"
        }
        FINAL_KEYWORDS = {
            "hu": "fejezetlen",
            "en": "incomplete"
        }
        CONCEDE_KEYWORDS = {
            "hu": "feladja",
            "en": "concedes"
        }
        ABANDON_KEYWORDS = {
            "hu": "megszakítása",
            "en": "chose to abandon"
        }

        for logrow_div in logrow_divs:

            class_value = logrow_div.get_attribute("class")
            class_list = class_value.split()

            if "smalltext" in class_list:
                # Move 2
                
                match = re.search(r'\d+', logrow_div.text)
                if match:
                    move_number = int(match.group())
                
                spans = logrow_div.find_elements(By.TAG_NAME, "span")
                for span in spans:
                    timeinfo = span.text.strip()

                    full_timestamp_pattern = r"(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})\.\s*(\d{1,2}):(\d{2}):(\d{2})"
                    match = re.match(full_timestamp_pattern, timeinfo)
                    if match :
                        stepDate = match.group(1) + "." + match.group(2).zfill(2) + "." + match.group(3).zfill(2) + "."
                        stepTime = match.group(4).zfill(2) + ":" + match.group(5) + ":" + match.group(6)
                    else :
                        time_pattern = r"(\d{1,2}):(\d{2}):(\d{2})"
                        match = re.match(time_pattern, timeinfo)
                        if match :
                            stepTime = match.group(1).zfill(2) + ":" + match.group(2) + ":" + match.group(3)
                        else :
                            stepTime = timeinfo
                    timeinfo = (stepDate + " " + stepTime    ).strip()
                    
                    if starttimeinfo == "" :
                        starttimeinfo = timeinfo 

            if "gamelogreview" in class_list:

                if move_number == 1 :
                    continue

                score = 0
                step_desc = logrow_div.text.strip()
                step_desc = step_desc.replace("\n", " ").replace("\r", " ")
                needtile = False
                needfeature = False
                keepfeature = False

                player_pos = 0
                if step_desc.startswith(playerObj1.name) :
                    player_pos = 1
                elif step_desc.startswith(playerObj2.name) :    
                    player_pos = 2
                
                if MEEPLE_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.MEEPLE
                    needfeature = True
                elif TILE_KEYWORDS[lang] in step_desc :
                    if carcevent != CarcEvent.DISCARD :
                        turn_number = turn_number + 1
                    carcevent = CarcEvent.TILE
                    turn_player_pos = player_pos
                    step_player_pos = player_pos
                    if start_player_pos == 0 :
                        start_player_pos = player_pos
                    needtile = True
                    logstart = True
                elif DISCARD_KEYWORDS[lang] in step_desc :
                    if carcevent != CarcEvent.DISCARD :
                        carcevent = CarcEvent.DISCARD
                        turn_number = turn_number + 1
                    turn_player_pos = player_pos
                    step_player_pos = player_pos
                    needtile = True
                elif COMPLETE_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.COMPLETE
                    step_player_pos = player_pos
                    needfeature = True
                elif FINALFIELD_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.FINAL
                    carcfeature = CarcFeature.FIELD
                    keepfeature = True
                    step_player_pos = 0
                elif POINTS_KEYWORDS[lang] in step_desc :
                    match = re.search(r'(\d+)\s+(pont|point)', step_desc, re.IGNORECASE)
                    if match:
                        score = int(match.group(1))
                    else :
                        score = 0
                    carcevent = CarcEvent.POINTS
                    step_player_pos = player_pos
                    needfeature = True
                    keepfeature = True # keep the feature of the previous step
                elif FINAL_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.FINAL
                    step_player_pos = 0
                    needfeature = True
                elif CONCEDE_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.CONCEDE
                    turn_player_pos = player_pos
                    step_player_pos = player_pos
                    conceded = True
                elif ABANDON_KEYWORDS[lang] in step_desc :
                    carcevent = CarcEvent.ABANDON
                    turn_player_pos = player_pos
                    step_player_pos = player_pos
                else :
                    continue

                if not keepfeature :
                    carcfeature = CarcFeature.VOID
                    if needfeature :
                        if CITY_KEYWORDS[lang] in step_desc :
                            carcfeature = CarcFeature.CITY
                        elif ROAD_KEYWORDS[lang] in step_desc :
                            carcfeature = CarcFeature.ROAD
                        elif MONASTERY_KEYWORDS[lang] in step_desc :
                            carcfeature = CarcFeature.MONASTERY
                        elif FIELD_KEYWORDS[lang] in step_desc :
                            carcfeature = CarcFeature.ROAD

                carctile = CarcTile.VOID
                if needtile :
                    try:
                        tile_art_div = logrow_div.find_element(By.CSS_SELECTOR, ".tile_art")
                        bg_position = tile_art_div.value_of_css_property("background-position")
                        carctile = get_carctile_by_bgpos(bg_position)
                    except:
                        pass

                step_number = step_number + 1
                carcstepObj = CarcStep(table_code=table_code, seq=step_number, turn=turn_number, bgamove=move_number, turnplayer=turn_player_pos, stepplayer=step_player_pos,
                                       event=carcevent, feature=carcfeature, tile=carctile, score=score, desc=step_desc, time=timeinfo, clock1="", clock2="")
                carcsteps.append(carcstepObj)


            if "reflexiontimes_block" in class_list:
                reflexion_divs = logrow_div.find_elements(By.CSS_SELECTOR, ".reflexiontimes")
                for reflexion_div in reflexion_divs:
                    reflexion_spans = reflexion_div.find_elements(By.TAG_NAME, "span")
                    for reflexion_span in reflexion_spans:
                        if carcstepObj != None :
                            if playerObj1.name in reflexion_div.get_attribute("textContent") :
                                carcstepObj.clock1 = reflexion_span.get_attribute("textContent").strip()
                                if startclock == "" and start_player_pos == 2 :
                                    startclock = carcstepObj.clock1;
                            elif playerObj2.name in reflexion_div.get_attribute("textContent") :
                                carcstepObj.clock2 = reflexion_span.get_attribute("textContent").strip()
                                if startclock == "" and start_player_pos == 1 :
                                    startclock = carcstepObj.clock2;

         
        print(f"No. of steps: {len(carcsteps)}")
        if len(carcsteps) == 0 :
            print("Gamelog not available...")
            exit_program()            
            #return          
           
        carcevent = CarcEvent.START
        carcstepObj = CarcStep(table_code=table_code, seq=1, turn=1, bgamove=1, turnplayer=start_player_pos, stepplayer=start_player_pos,
                               event=carcevent, feature=carcfeature, tile=carctile, score=0, desc="", time=starttimeinfo, clock1=startclock, clock2=startclock)
        carcsteps.append(carcstepObj)

        if tableplayerObj2.outoftime and tableplayerObj1.score == 1 and not conceded :
            step_number = step_number + 1
            carcevent = CarcEvent.TIMEOVER
            carcstepObj = CarcStep(table_code=table_code, seq=step_number, turn=turn_number, bgamove=move_number, turnplayer=turn_player_pos, stepplayer=turn_player_pos,
                                   event=carcevent, feature=CarcFeature.VOID, tile=CarcTile.VOID, score=0, desc="", time=timeinfo, clock1="", clock2="")
            carcsteps.append(carcstepObj)
            

        # post processing 1: filling missing clock values
        turnswithclock1 = set()
        turnswithclock2 = set()
        for carcstep in carcsteps:
            if carcstep.clock1 != "":
                turnswithclock1.add(carcstep.turn)
            if carcstep.clock2 != "":
                turnswithclock2.add(carcstep.turn)
        lastturn = 0

        for index in range(2):
            if index == 0:
                carcsteps.sort(key=lambda carcstep: -1*carcstep.seq)
            else:    
                carcsteps.sort(key=lambda carcstep: carcstep.seq)

            prevclock1 = ""
            prevclock2 = ""
            prevturn = 0

            for carcstep in carcsteps:
                if index == 0 and lastturn == 0:
                    lastturn = carcstep.turn
                
                if carcstep.clock1 == "" and carcstep.turn in turnswithclock1:
                    if carcstep.turn == prevturn and prevclock1 != "":
                        carcstep.clock1 = prevclock1
                if carcstep.clock2 == "" and carcstep.turn in turnswithclock2:
                    if carcstep.turn == prevturn and prevclock2 != "":
                        carcstep.clock2 = prevclock2

                if carcstep.clock1 == "" and not carcstep.turn in turnswithclock1:
                    if ((index == 0 and carcstep.turnplayer == 2) or (index == 1 and (carcstep.turnplayer == 1 or carcstep.turn == lastturn)) ) and prevclock1 != "":
                        carcstep.clock1 = prevclock1
                if carcstep.clock2 == "" and not carcstep.turn in turnswithclock2:
                    if ((index == 0 and carcstep.turnplayer == 1) or (index == 1 and carcstep.turnplayer == 2)) and prevclock2 != "":
                        carcstep.clock2 = prevclock2

                prevclock1 = carcstep.clock1
                prevclock2 = carcstep.clock2
                prevturn = carcstep.turn

            
        if output_dir != "" :
           output_file = os.path.join(output_dir, "table_" + table_code + "_steps.csv")
           print("Writing steps to file: " + output_file)

           try:
               with open(output_file, "w", encoding="utf-8") as file:
                   line= "table_code|seq|turn|bgamove|turnplayer|stepplayer|event|feature|tile|score|desc|time|clock1|clock2\n"
                   file.write(line)
                   for carcstep in carcsteps:
                       line = f"{carcstep.table_code}|{carcstep.seq}|{carcstep.turn}|{carcstep.bgamove}|{carcstep.turnplayer}|{carcstep.stepplayer}|{carcstep.event.value}|"\
                              f"{carcstep.feature.value}|{carcstep.tile.value}|{carcstep.score}|{carcstep.desc}|{carcstep.time}|{carcstep.clock1}|{carcstep.clock2}\n" 
                       file.write(line)
               print("Done")
           except Exception as e:
               print(f"Error: {e}")       
         


    if "db" in subfunc_set :
        needcloseconn = False
        print("Saving data")

        try:
            if connection is None :
                connection = get_connection()
                needcloseconn = True

            cursor = connection.cursor()
 
            # tournament 
            if not tournamentObj is None :
                
                cursor.execute("SELECT tournament_id FROM tournament WHERE code = ?", (tournamentObj.code,))
                row = cursor.fetchone()
                if row:
                    tournamentObj.id = row[0]
                else:
                    cursor.execute("INSERT INTO tournament (code, name, inbga) VALUES (?, ?, ?)", 
                                   (tournamentObj.code, tournamentObj.name, tournamentObj.inbga))
                    tournamentObj.id = cursor.lastrowid
                tableObj.tournament_id = tournamentObj.id    

            # table
            cursor.execute("SELECT table_id FROM table_ WHERE code = ?", (tableObj.code,))
            row = cursor.fetchone()
            if row:
                tableObj.id = row[0]
                cursor.execute("UPDATE table_ SET tournament_id = ?, game_code = ?, width = ?, height = ?, duration = ?, ccities = ? WHERE table_id = ?", 
                               (tableObj.tournament_id, tableObj.game_code, tableObj.width, tableObj.height, tableObj.duration, tableObj.ccities, tableObj.id))
            else:
                cursor.execute("INSERT INTO table_ (tournament_id, code, game_code, width, height, duration, ccities) VALUES (?, ?, ?, ?, ?, ?, ?)", 
                               (tableObj.tournament_id, tableObj.code, tableObj.game_code, tableObj.width, tableObj.height, tableObj.duration, tableObj.ccities))
                tableObj.id = cursor.lastrowid

            # players, tableplayers
            for i in range(2):
                if i == 0 :
                    playerObj = playerObj1
                    tableplayerObj = tableplayerObj1
                else :   
                    playerObj = playerObj2
                    tableplayerObj = tableplayerObj2
                
                cursor.execute("SELECT player_id FROM player WHERE code = ?", (playerObj.code,))
                row = cursor.fetchone()
                if row:
                    playerObj.id = row[0]
                else:
                    cursor.execute("INSERT INTO player (code, name) VALUES (?, ?)", 
                                   (playerObj.code, playerObj.name))
                    playerObj.id = cursor.lastrowid

                tableplayerObj.player_id = playerObj.id
                tableplayerObj.table_id = tableObj.id

                cursor.execute("SELECT tableplayer_id FROM tableplayer WHERE table_id = ? AND player_id = ?", 
                               (tableplayerObj.table_id, tableplayerObj.player_id))
                row = cursor.fetchone()
                if row:
                    tableplayerObj.id = row[0]
                    cursor.execute("UPDATE tableplayer SET seq = ?, score = ?, newrank = ?, rankchg = ?, winner = ?, roadpt = ?, citypt = ?, monasterypt = ?, fieldpt = ?, meeples = ?, time = ?, outoftime = ? WHERE tableplayer_id = ?", 
                                   (tableplayerObj.seq, tableplayerObj.score, tableplayerObj.newrank, tableplayerObj.rankchg, tableplayerObj.winner,
                                    tableplayerObj.roadpt, tableplayerObj.citypt, tableplayerObj.monasterypt, tableplayerObj.fieldpt, tableplayerObj.meeples, 
                                    tableplayerObj.time, tableplayerObj.outoftime, tableplayerObj.id))
                else:
                    cursor.execute("INSERT INTO tableplayer (table_id, player_id, seq, score, newrank, rankchg, winner, roadpt, citypt, monasterypt, fieldpt, meeples, time, outoftime) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", 
                                   (tableplayerObj.table_id, tableplayerObj.player_id, tableplayerObj.seq, tableplayerObj.score, tableplayerObj.newrank, tableplayerObj.rankchg, tableplayerObj.winner,
                                    tableplayerObj.roadpt, tableplayerObj.citypt, tableplayerObj.monasterypt, tableplayerObj.fieldpt, tableplayerObj.meeples, tableplayerObj.time, tableplayerObj.outoftime))
                    tableplayerObj.id = cursor.lastrowid

            # carcsteps
            if not "skipreview" in subfunc_set :
                cursor.execute("SELECT COUNT(*) FROM carcstep WHERE table_id = ?", (tableObj.id,))
                count = cursor.fetchone()[0]

                if count > 0:
                    cursor.execute("DELETE FROM carcstep WHERE table_id = ?", (tableObj.id,))
            
                for carcstepObj in carcsteps:
                    carcstepObj.table_id = tableObj.id
                    cursor.execute("INSERT INTO carcstep (table_id, seq, turn, bgamove, turnplayer, stepplayer, event, feature, tile, score, desc, time, clock1, clock2) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                                   (carcstepObj.table_id, carcstepObj.seq, carcstepObj.turn, carcstepObj.bgamove, carcstepObj.turnplayer, carcstepObj.stepplayer,
                                    carcstepObj.event, carcstepObj.feature, carcstepObj.tile, carcstepObj.score, carcstepObj.desc, carcstepObj.time, carcstepObj.clock1, carcstepObj.clock2))                
                    carcstepObj.id = cursor.lastrowid

            connection.commit()

        except Exception as e:
            print(f"Error: {e}")
            if connection:
                connection.rollback()
        finally:
            if needcloseconn :
                print("Closing database connection")
                connection.close()

    end_millisec = int(time.time() * 1000)

    print("Complete runtime: " + str(end_millisec - start_millisec) + " ms")


loggedIn = False
popupClosed = False
lang = "hu"

# 1st param.: function to call
argnum = len(sys.argv)

if argnum > 1 :
    func = sys.argv[1]
else :
    func = 'elo_hist'

table_id = ""
trn_id = ""
game_def = ""
player_names = ""
file_name = ""
output_dir = ""
min_date = ""
max_date = ""
trn_code = ""
trn_name = ""
subfunc_set = set()

if argnum > 2 :
    for argpos in range(2, argnum):
        if argpos == argnum - 1 and sys.argv[argpos][:2] != '--':
            break
            
        match sys.argv[argpos]:
            case "-t":
                trn_id = sys.argv[argpos + 1]
            case "-b":
                table_id = sys.argv[argpos + 1]
            case "-g":
                game_def = sys.argv[argpos + 1]
            case "-p":
                player_names = sys.argv[argpos + 1]
            case "-f":
                file_name = sys.argv[argpos + 1]
            case "-o":
                output_dir = sys.argv[argpos + 1]
            case "-mn":
                min_date = sys.argv[argpos + 1]
            case "-mx":
                max_date = sys.argv[argpos + 1]
            case "-tc":
                trn_code = sys.argv[argpos + 1]
            case "-tn":
                trn_name = sys.argv[argpos + 1]
            case "--avg":
                subfunc_set.add("avg")
            case "--db":
                subfunc_set.add("db")
            case "--reset":
                subfunc_set.add("reset")
            case "--skipreview":
                subfunc_set.add("skipreview")
                

print("game: " + game_def + ", player: " + player_names + ", file: " + file_name)            

match func :
    case "elo_hist":
        elo_hist(game_def, player_names, min_date, max_date, file_name)
    case "login":    
        login()
    case "init_db":    
        init_db()
    case "trn_tablecoll":
        trn_tablecoll(trn_id, file_name)
    case "carc_tablelistproc":
        tablelistproc(file_name, output_dir)
    case "carc_tableproc":
        tableproc(table_id, output_dir, trn_code=trn_code, trn_name=trn_name)
    case _:
        print("unknown function")
    
 
